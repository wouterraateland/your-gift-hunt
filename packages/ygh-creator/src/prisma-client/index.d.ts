// Code generated by Prisma (prisma@1.25.7). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  action: (where?: ActionWhereInput) => Promise<boolean>;
  actionPayload: (where?: ActionPayloadWhereInput) => Promise<boolean>;
  actionPayloadInputValue: (
    where?: ActionPayloadInputValueWhereInput
  ) => Promise<boolean>;
  actionRequirement: (where?: ActionRequirementWhereInput) => Promise<boolean>;
  actionRequirementPayload: (
    where?: ActionRequirementPayloadWhereInput
  ) => Promise<boolean>;
  actionRequirementPayloadEntity: (
    where?: ActionRequirementPayloadEntityWhereInput
  ) => Promise<boolean>;
  actionRequirementPayloadInputValue: (
    where?: ActionRequirementPayloadInputValueWhereInput
  ) => Promise<boolean>;
  entity: (where?: EntityWhereInput) => Promise<boolean>;
  entityField: (where?: EntityFieldWhereInput) => Promise<boolean>;
  entityInstance: (where?: EntityInstanceWhereInput) => Promise<boolean>;
  entityInstanceField: (
    where?: EntityInstanceFieldWhereInput
  ) => Promise<boolean>;
  entityInstanceState: (
    where?: EntityInstanceStateWhereInput
  ) => Promise<boolean>;
  entityInstanceStateTransition: (
    where?: EntityInstanceStateTransitionWhereInput
  ) => Promise<boolean>;
  entityState: (where?: EntityStateWhereInput) => Promise<boolean>;
  entityStateTransition: (
    where?: EntityStateTransitionWhereInput
  ) => Promise<boolean>;
  game: (where?: GameWhereInput) => Promise<boolean>;
  gamePlay: (where?: GamePlayWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  action: (where: ActionWhereUniqueInput) => ActionPromise;
  actions: (args?: {
    where?: ActionWhereInput;
    orderBy?: ActionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Action>;
  actionsConnection: (args?: {
    where?: ActionWhereInput;
    orderBy?: ActionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ActionConnectionPromise;
  actionPayload: (where: ActionPayloadWhereUniqueInput) => ActionPayloadPromise;
  actionPayloads: (args?: {
    where?: ActionPayloadWhereInput;
    orderBy?: ActionPayloadOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ActionPayload>;
  actionPayloadsConnection: (args?: {
    where?: ActionPayloadWhereInput;
    orderBy?: ActionPayloadOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ActionPayloadConnectionPromise;
  actionPayloadInputValue: (
    where: ActionPayloadInputValueWhereUniqueInput
  ) => ActionPayloadInputValuePromise;
  actionPayloadInputValues: (args?: {
    where?: ActionPayloadInputValueWhereInput;
    orderBy?: ActionPayloadInputValueOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ActionPayloadInputValue>;
  actionPayloadInputValuesConnection: (args?: {
    where?: ActionPayloadInputValueWhereInput;
    orderBy?: ActionPayloadInputValueOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ActionPayloadInputValueConnectionPromise;
  actionRequirement: (
    where: ActionRequirementWhereUniqueInput
  ) => ActionRequirementPromise;
  actionRequirements: (args?: {
    where?: ActionRequirementWhereInput;
    orderBy?: ActionRequirementOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ActionRequirement>;
  actionRequirementsConnection: (args?: {
    where?: ActionRequirementWhereInput;
    orderBy?: ActionRequirementOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ActionRequirementConnectionPromise;
  actionRequirementPayload: (
    where: ActionRequirementPayloadWhereUniqueInput
  ) => ActionRequirementPayloadPromise;
  actionRequirementPayloads: (args?: {
    where?: ActionRequirementPayloadWhereInput;
    orderBy?: ActionRequirementPayloadOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ActionRequirementPayload>;
  actionRequirementPayloadsConnection: (args?: {
    where?: ActionRequirementPayloadWhereInput;
    orderBy?: ActionRequirementPayloadOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ActionRequirementPayloadConnectionPromise;
  actionRequirementPayloadEntity: (
    where: ActionRequirementPayloadEntityWhereUniqueInput
  ) => ActionRequirementPayloadEntityPromise;
  actionRequirementPayloadEntities: (args?: {
    where?: ActionRequirementPayloadEntityWhereInput;
    orderBy?: ActionRequirementPayloadEntityOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ActionRequirementPayloadEntity>;
  actionRequirementPayloadEntitiesConnection: (args?: {
    where?: ActionRequirementPayloadEntityWhereInput;
    orderBy?: ActionRequirementPayloadEntityOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ActionRequirementPayloadEntityConnectionPromise;
  actionRequirementPayloadInputValue: (
    where: ActionRequirementPayloadInputValueWhereUniqueInput
  ) => ActionRequirementPayloadInputValuePromise;
  actionRequirementPayloadInputValues: (args?: {
    where?: ActionRequirementPayloadInputValueWhereInput;
    orderBy?: ActionRequirementPayloadInputValueOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ActionRequirementPayloadInputValue>;
  actionRequirementPayloadInputValuesConnection: (args?: {
    where?: ActionRequirementPayloadInputValueWhereInput;
    orderBy?: ActionRequirementPayloadInputValueOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ActionRequirementPayloadInputValueConnectionPromise;
  entity: (where: EntityWhereUniqueInput) => EntityPromise;
  entities: (args?: {
    where?: EntityWhereInput;
    orderBy?: EntityOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Entity>;
  entitiesConnection: (args?: {
    where?: EntityWhereInput;
    orderBy?: EntityOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => EntityConnectionPromise;
  entityField: (where: EntityFieldWhereUniqueInput) => EntityFieldPromise;
  entityFields: (args?: {
    where?: EntityFieldWhereInput;
    orderBy?: EntityFieldOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<EntityField>;
  entityFieldsConnection: (args?: {
    where?: EntityFieldWhereInput;
    orderBy?: EntityFieldOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => EntityFieldConnectionPromise;
  entityInstance: (
    where: EntityInstanceWhereUniqueInput
  ) => EntityInstancePromise;
  entityInstances: (args?: {
    where?: EntityInstanceWhereInput;
    orderBy?: EntityInstanceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<EntityInstance>;
  entityInstancesConnection: (args?: {
    where?: EntityInstanceWhereInput;
    orderBy?: EntityInstanceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => EntityInstanceConnectionPromise;
  entityInstanceField: (
    where: EntityInstanceFieldWhereUniqueInput
  ) => EntityInstanceFieldPromise;
  entityInstanceFields: (args?: {
    where?: EntityInstanceFieldWhereInput;
    orderBy?: EntityInstanceFieldOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<EntityInstanceField>;
  entityInstanceFieldsConnection: (args?: {
    where?: EntityInstanceFieldWhereInput;
    orderBy?: EntityInstanceFieldOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => EntityInstanceFieldConnectionPromise;
  entityInstanceState: (
    where: EntityInstanceStateWhereUniqueInput
  ) => EntityInstanceStatePromise;
  entityInstanceStates: (args?: {
    where?: EntityInstanceStateWhereInput;
    orderBy?: EntityInstanceStateOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<EntityInstanceState>;
  entityInstanceStatesConnection: (args?: {
    where?: EntityInstanceStateWhereInput;
    orderBy?: EntityInstanceStateOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => EntityInstanceStateConnectionPromise;
  entityInstanceStateTransition: (
    where: EntityInstanceStateTransitionWhereUniqueInput
  ) => EntityInstanceStateTransitionPromise;
  entityInstanceStateTransitions: (args?: {
    where?: EntityInstanceStateTransitionWhereInput;
    orderBy?: EntityInstanceStateTransitionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<EntityInstanceStateTransition>;
  entityInstanceStateTransitionsConnection: (args?: {
    where?: EntityInstanceStateTransitionWhereInput;
    orderBy?: EntityInstanceStateTransitionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => EntityInstanceStateTransitionConnectionPromise;
  entityState: (where: EntityStateWhereUniqueInput) => EntityStatePromise;
  entityStates: (args?: {
    where?: EntityStateWhereInput;
    orderBy?: EntityStateOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<EntityState>;
  entityStatesConnection: (args?: {
    where?: EntityStateWhereInput;
    orderBy?: EntityStateOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => EntityStateConnectionPromise;
  entityStateTransition: (
    where: EntityStateTransitionWhereUniqueInput
  ) => EntityStateTransitionPromise;
  entityStateTransitions: (args?: {
    where?: EntityStateTransitionWhereInput;
    orderBy?: EntityStateTransitionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<EntityStateTransition>;
  entityStateTransitionsConnection: (args?: {
    where?: EntityStateTransitionWhereInput;
    orderBy?: EntityStateTransitionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => EntityStateTransitionConnectionPromise;
  game: (where: GameWhereUniqueInput) => GamePromise;
  games: (args?: {
    where?: GameWhereInput;
    orderBy?: GameOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Game>;
  gamesConnection: (args?: {
    where?: GameWhereInput;
    orderBy?: GameOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => GameConnectionPromise;
  gamePlay: (where: GamePlayWhereUniqueInput) => GamePlayPromise;
  gamePlays: (args?: {
    where?: GamePlayWhereInput;
    orderBy?: GamePlayOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<GamePlay>;
  gamePlaysConnection: (args?: {
    where?: GamePlayWhereInput;
    orderBy?: GamePlayOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => GamePlayConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserPromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createAction: (data: ActionCreateInput) => ActionPromise;
  updateAction: (args: {
    data: ActionUpdateInput;
    where: ActionWhereUniqueInput;
  }) => ActionPromise;
  updateManyActions: (args: {
    data: ActionUpdateManyMutationInput;
    where?: ActionWhereInput;
  }) => BatchPayloadPromise;
  upsertAction: (args: {
    where: ActionWhereUniqueInput;
    create: ActionCreateInput;
    update: ActionUpdateInput;
  }) => ActionPromise;
  deleteAction: (where: ActionWhereUniqueInput) => ActionPromise;
  deleteManyActions: (where?: ActionWhereInput) => BatchPayloadPromise;
  createActionPayload: (data: ActionPayloadCreateInput) => ActionPayloadPromise;
  updateActionPayload: (args: {
    data: ActionPayloadUpdateInput;
    where: ActionPayloadWhereUniqueInput;
  }) => ActionPayloadPromise;
  upsertActionPayload: (args: {
    where: ActionPayloadWhereUniqueInput;
    create: ActionPayloadCreateInput;
    update: ActionPayloadUpdateInput;
  }) => ActionPayloadPromise;
  deleteActionPayload: (
    where: ActionPayloadWhereUniqueInput
  ) => ActionPayloadPromise;
  deleteManyActionPayloads: (
    where?: ActionPayloadWhereInput
  ) => BatchPayloadPromise;
  createActionPayloadInputValue: (
    data: ActionPayloadInputValueCreateInput
  ) => ActionPayloadInputValuePromise;
  updateActionPayloadInputValue: (args: {
    data: ActionPayloadInputValueUpdateInput;
    where: ActionPayloadInputValueWhereUniqueInput;
  }) => ActionPayloadInputValuePromise;
  updateManyActionPayloadInputValues: (args: {
    data: ActionPayloadInputValueUpdateManyMutationInput;
    where?: ActionPayloadInputValueWhereInput;
  }) => BatchPayloadPromise;
  upsertActionPayloadInputValue: (args: {
    where: ActionPayloadInputValueWhereUniqueInput;
    create: ActionPayloadInputValueCreateInput;
    update: ActionPayloadInputValueUpdateInput;
  }) => ActionPayloadInputValuePromise;
  deleteActionPayloadInputValue: (
    where: ActionPayloadInputValueWhereUniqueInput
  ) => ActionPayloadInputValuePromise;
  deleteManyActionPayloadInputValues: (
    where?: ActionPayloadInputValueWhereInput
  ) => BatchPayloadPromise;
  createActionRequirement: (
    data: ActionRequirementCreateInput
  ) => ActionRequirementPromise;
  updateActionRequirement: (args: {
    data: ActionRequirementUpdateInput;
    where: ActionRequirementWhereUniqueInput;
  }) => ActionRequirementPromise;
  updateManyActionRequirements: (args: {
    data: ActionRequirementUpdateManyMutationInput;
    where?: ActionRequirementWhereInput;
  }) => BatchPayloadPromise;
  upsertActionRequirement: (args: {
    where: ActionRequirementWhereUniqueInput;
    create: ActionRequirementCreateInput;
    update: ActionRequirementUpdateInput;
  }) => ActionRequirementPromise;
  deleteActionRequirement: (
    where: ActionRequirementWhereUniqueInput
  ) => ActionRequirementPromise;
  deleteManyActionRequirements: (
    where?: ActionRequirementWhereInput
  ) => BatchPayloadPromise;
  createActionRequirementPayload: (
    data: ActionRequirementPayloadCreateInput
  ) => ActionRequirementPayloadPromise;
  updateActionRequirementPayload: (args: {
    data: ActionRequirementPayloadUpdateInput;
    where: ActionRequirementPayloadWhereUniqueInput;
  }) => ActionRequirementPayloadPromise;
  upsertActionRequirementPayload: (args: {
    where: ActionRequirementPayloadWhereUniqueInput;
    create: ActionRequirementPayloadCreateInput;
    update: ActionRequirementPayloadUpdateInput;
  }) => ActionRequirementPayloadPromise;
  deleteActionRequirementPayload: (
    where: ActionRequirementPayloadWhereUniqueInput
  ) => ActionRequirementPayloadPromise;
  deleteManyActionRequirementPayloads: (
    where?: ActionRequirementPayloadWhereInput
  ) => BatchPayloadPromise;
  createActionRequirementPayloadEntity: (
    data: ActionRequirementPayloadEntityCreateInput
  ) => ActionRequirementPayloadEntityPromise;
  updateActionRequirementPayloadEntity: (args: {
    data: ActionRequirementPayloadEntityUpdateInput;
    where: ActionRequirementPayloadEntityWhereUniqueInput;
  }) => ActionRequirementPayloadEntityPromise;
  upsertActionRequirementPayloadEntity: (args: {
    where: ActionRequirementPayloadEntityWhereUniqueInput;
    create: ActionRequirementPayloadEntityCreateInput;
    update: ActionRequirementPayloadEntityUpdateInput;
  }) => ActionRequirementPayloadEntityPromise;
  deleteActionRequirementPayloadEntity: (
    where: ActionRequirementPayloadEntityWhereUniqueInput
  ) => ActionRequirementPayloadEntityPromise;
  deleteManyActionRequirementPayloadEntities: (
    where?: ActionRequirementPayloadEntityWhereInput
  ) => BatchPayloadPromise;
  createActionRequirementPayloadInputValue: (
    data: ActionRequirementPayloadInputValueCreateInput
  ) => ActionRequirementPayloadInputValuePromise;
  updateActionRequirementPayloadInputValue: (args: {
    data: ActionRequirementPayloadInputValueUpdateInput;
    where: ActionRequirementPayloadInputValueWhereUniqueInput;
  }) => ActionRequirementPayloadInputValuePromise;
  updateManyActionRequirementPayloadInputValues: (args: {
    data: ActionRequirementPayloadInputValueUpdateManyMutationInput;
    where?: ActionRequirementPayloadInputValueWhereInput;
  }) => BatchPayloadPromise;
  upsertActionRequirementPayloadInputValue: (args: {
    where: ActionRequirementPayloadInputValueWhereUniqueInput;
    create: ActionRequirementPayloadInputValueCreateInput;
    update: ActionRequirementPayloadInputValueUpdateInput;
  }) => ActionRequirementPayloadInputValuePromise;
  deleteActionRequirementPayloadInputValue: (
    where: ActionRequirementPayloadInputValueWhereUniqueInput
  ) => ActionRequirementPayloadInputValuePromise;
  deleteManyActionRequirementPayloadInputValues: (
    where?: ActionRequirementPayloadInputValueWhereInput
  ) => BatchPayloadPromise;
  createEntity: (data: EntityCreateInput) => EntityPromise;
  updateEntity: (args: {
    data: EntityUpdateInput;
    where: EntityWhereUniqueInput;
  }) => EntityPromise;
  updateManyEntities: (args: {
    data: EntityUpdateManyMutationInput;
    where?: EntityWhereInput;
  }) => BatchPayloadPromise;
  upsertEntity: (args: {
    where: EntityWhereUniqueInput;
    create: EntityCreateInput;
    update: EntityUpdateInput;
  }) => EntityPromise;
  deleteEntity: (where: EntityWhereUniqueInput) => EntityPromise;
  deleteManyEntities: (where?: EntityWhereInput) => BatchPayloadPromise;
  createEntityField: (data: EntityFieldCreateInput) => EntityFieldPromise;
  updateEntityField: (args: {
    data: EntityFieldUpdateInput;
    where: EntityFieldWhereUniqueInput;
  }) => EntityFieldPromise;
  updateManyEntityFields: (args: {
    data: EntityFieldUpdateManyMutationInput;
    where?: EntityFieldWhereInput;
  }) => BatchPayloadPromise;
  upsertEntityField: (args: {
    where: EntityFieldWhereUniqueInput;
    create: EntityFieldCreateInput;
    update: EntityFieldUpdateInput;
  }) => EntityFieldPromise;
  deleteEntityField: (where: EntityFieldWhereUniqueInput) => EntityFieldPromise;
  deleteManyEntityFields: (
    where?: EntityFieldWhereInput
  ) => BatchPayloadPromise;
  createEntityInstance: (
    data: EntityInstanceCreateInput
  ) => EntityInstancePromise;
  updateEntityInstance: (args: {
    data: EntityInstanceUpdateInput;
    where: EntityInstanceWhereUniqueInput;
  }) => EntityInstancePromise;
  updateManyEntityInstances: (args: {
    data: EntityInstanceUpdateManyMutationInput;
    where?: EntityInstanceWhereInput;
  }) => BatchPayloadPromise;
  upsertEntityInstance: (args: {
    where: EntityInstanceWhereUniqueInput;
    create: EntityInstanceCreateInput;
    update: EntityInstanceUpdateInput;
  }) => EntityInstancePromise;
  deleteEntityInstance: (
    where: EntityInstanceWhereUniqueInput
  ) => EntityInstancePromise;
  deleteManyEntityInstances: (
    where?: EntityInstanceWhereInput
  ) => BatchPayloadPromise;
  createEntityInstanceField: (
    data: EntityInstanceFieldCreateInput
  ) => EntityInstanceFieldPromise;
  updateEntityInstanceField: (args: {
    data: EntityInstanceFieldUpdateInput;
    where: EntityInstanceFieldWhereUniqueInput;
  }) => EntityInstanceFieldPromise;
  updateManyEntityInstanceFields: (args: {
    data: EntityInstanceFieldUpdateManyMutationInput;
    where?: EntityInstanceFieldWhereInput;
  }) => BatchPayloadPromise;
  upsertEntityInstanceField: (args: {
    where: EntityInstanceFieldWhereUniqueInput;
    create: EntityInstanceFieldCreateInput;
    update: EntityInstanceFieldUpdateInput;
  }) => EntityInstanceFieldPromise;
  deleteEntityInstanceField: (
    where: EntityInstanceFieldWhereUniqueInput
  ) => EntityInstanceFieldPromise;
  deleteManyEntityInstanceFields: (
    where?: EntityInstanceFieldWhereInput
  ) => BatchPayloadPromise;
  createEntityInstanceState: (
    data: EntityInstanceStateCreateInput
  ) => EntityInstanceStatePromise;
  updateEntityInstanceState: (args: {
    data: EntityInstanceStateUpdateInput;
    where: EntityInstanceStateWhereUniqueInput;
  }) => EntityInstanceStatePromise;
  upsertEntityInstanceState: (args: {
    where: EntityInstanceStateWhereUniqueInput;
    create: EntityInstanceStateCreateInput;
    update: EntityInstanceStateUpdateInput;
  }) => EntityInstanceStatePromise;
  deleteEntityInstanceState: (
    where: EntityInstanceStateWhereUniqueInput
  ) => EntityInstanceStatePromise;
  deleteManyEntityInstanceStates: (
    where?: EntityInstanceStateWhereInput
  ) => BatchPayloadPromise;
  createEntityInstanceStateTransition: (
    data: EntityInstanceStateTransitionCreateInput
  ) => EntityInstanceStateTransitionPromise;
  updateEntityInstanceStateTransition: (args: {
    data: EntityInstanceStateTransitionUpdateInput;
    where: EntityInstanceStateTransitionWhereUniqueInput;
  }) => EntityInstanceStateTransitionPromise;
  upsertEntityInstanceStateTransition: (args: {
    where: EntityInstanceStateTransitionWhereUniqueInput;
    create: EntityInstanceStateTransitionCreateInput;
    update: EntityInstanceStateTransitionUpdateInput;
  }) => EntityInstanceStateTransitionPromise;
  deleteEntityInstanceStateTransition: (
    where: EntityInstanceStateTransitionWhereUniqueInput
  ) => EntityInstanceStateTransitionPromise;
  deleteManyEntityInstanceStateTransitions: (
    where?: EntityInstanceStateTransitionWhereInput
  ) => BatchPayloadPromise;
  createEntityState: (data: EntityStateCreateInput) => EntityStatePromise;
  updateEntityState: (args: {
    data: EntityStateUpdateInput;
    where: EntityStateWhereUniqueInput;
  }) => EntityStatePromise;
  updateManyEntityStates: (args: {
    data: EntityStateUpdateManyMutationInput;
    where?: EntityStateWhereInput;
  }) => BatchPayloadPromise;
  upsertEntityState: (args: {
    where: EntityStateWhereUniqueInput;
    create: EntityStateCreateInput;
    update: EntityStateUpdateInput;
  }) => EntityStatePromise;
  deleteEntityState: (where: EntityStateWhereUniqueInput) => EntityStatePromise;
  deleteManyEntityStates: (
    where?: EntityStateWhereInput
  ) => BatchPayloadPromise;
  createEntityStateTransition: (
    data: EntityStateTransitionCreateInput
  ) => EntityStateTransitionPromise;
  updateEntityStateTransition: (args: {
    data: EntityStateTransitionUpdateInput;
    where: EntityStateTransitionWhereUniqueInput;
  }) => EntityStateTransitionPromise;
  upsertEntityStateTransition: (args: {
    where: EntityStateTransitionWhereUniqueInput;
    create: EntityStateTransitionCreateInput;
    update: EntityStateTransitionUpdateInput;
  }) => EntityStateTransitionPromise;
  deleteEntityStateTransition: (
    where: EntityStateTransitionWhereUniqueInput
  ) => EntityStateTransitionPromise;
  deleteManyEntityStateTransitions: (
    where?: EntityStateTransitionWhereInput
  ) => BatchPayloadPromise;
  createGame: (data: GameCreateInput) => GamePromise;
  updateGame: (args: {
    data: GameUpdateInput;
    where: GameWhereUniqueInput;
  }) => GamePromise;
  updateManyGames: (args: {
    data: GameUpdateManyMutationInput;
    where?: GameWhereInput;
  }) => BatchPayloadPromise;
  upsertGame: (args: {
    where: GameWhereUniqueInput;
    create: GameCreateInput;
    update: GameUpdateInput;
  }) => GamePromise;
  deleteGame: (where: GameWhereUniqueInput) => GamePromise;
  deleteManyGames: (where?: GameWhereInput) => BatchPayloadPromise;
  createGamePlay: (data: GamePlayCreateInput) => GamePlayPromise;
  updateGamePlay: (args: {
    data: GamePlayUpdateInput;
    where: GamePlayWhereUniqueInput;
  }) => GamePlayPromise;
  upsertGamePlay: (args: {
    where: GamePlayWhereUniqueInput;
    create: GamePlayCreateInput;
    update: GamePlayUpdateInput;
  }) => GamePlayPromise;
  deleteGamePlay: (where: GamePlayWhereUniqueInput) => GamePlayPromise;
  deleteManyGamePlays: (where?: GamePlayWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  action: (
    where?: ActionSubscriptionWhereInput
  ) => ActionSubscriptionPayloadSubscription;
  actionPayload: (
    where?: ActionPayloadSubscriptionWhereInput
  ) => ActionPayloadSubscriptionPayloadSubscription;
  actionPayloadInputValue: (
    where?: ActionPayloadInputValueSubscriptionWhereInput
  ) => ActionPayloadInputValueSubscriptionPayloadSubscription;
  actionRequirement: (
    where?: ActionRequirementSubscriptionWhereInput
  ) => ActionRequirementSubscriptionPayloadSubscription;
  actionRequirementPayload: (
    where?: ActionRequirementPayloadSubscriptionWhereInput
  ) => ActionRequirementPayloadSubscriptionPayloadSubscription;
  actionRequirementPayloadEntity: (
    where?: ActionRequirementPayloadEntitySubscriptionWhereInput
  ) => ActionRequirementPayloadEntitySubscriptionPayloadSubscription;
  actionRequirementPayloadInputValue: (
    where?: ActionRequirementPayloadInputValueSubscriptionWhereInput
  ) => ActionRequirementPayloadInputValueSubscriptionPayloadSubscription;
  entity: (
    where?: EntitySubscriptionWhereInput
  ) => EntitySubscriptionPayloadSubscription;
  entityField: (
    where?: EntityFieldSubscriptionWhereInput
  ) => EntityFieldSubscriptionPayloadSubscription;
  entityInstance: (
    where?: EntityInstanceSubscriptionWhereInput
  ) => EntityInstanceSubscriptionPayloadSubscription;
  entityInstanceField: (
    where?: EntityInstanceFieldSubscriptionWhereInput
  ) => EntityInstanceFieldSubscriptionPayloadSubscription;
  entityInstanceState: (
    where?: EntityInstanceStateSubscriptionWhereInput
  ) => EntityInstanceStateSubscriptionPayloadSubscription;
  entityInstanceStateTransition: (
    where?: EntityInstanceStateTransitionSubscriptionWhereInput
  ) => EntityInstanceStateTransitionSubscriptionPayloadSubscription;
  entityState: (
    where?: EntityStateSubscriptionWhereInput
  ) => EntityStateSubscriptionPayloadSubscription;
  entityStateTransition: (
    where?: EntityStateTransitionSubscriptionWhereInput
  ) => EntityStateTransitionSubscriptionPayloadSubscription;
  game: (
    where?: GameSubscriptionWhereInput
  ) => GameSubscriptionPayloadSubscription;
  gamePlay: (
    where?: GamePlaySubscriptionWhereInput
  ) => GamePlaySubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type ActionType =
  | "USE"
  | "TARGET_OF_USE"
  | "INPUT"
  | "TRANSFORM"
  | "TRIGGER"
  | "UNLOCK"
  | "IDENTIFY_HELPER";

export type FieldType =
  | "STRING"
  | "NUMBER"
  | "BOOLEAN"
  | "TIMESTAMP"
  | "GEOPOINT";

export type GameOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "slug_ASC"
  | "slug_DESC"
  | "description_ASC"
  | "description_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type GamePlayOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ActionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "type_ASC"
  | "type_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type EntityInstanceOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "description_ASC"
  | "description_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type EntityFieldOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "info_ASC"
  | "info_DESC"
  | "label_ASC"
  | "label_DESC"
  | "type_ASC"
  | "type_DESC"
  | "isMulti_ASC"
  | "isMulti_DESC"
  | "isSecret_ASC"
  | "isSecret_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type EntityStateOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "description_ASC"
  | "description_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type EntityStateTransitionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ActionRequirementOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "type_ASC"
  | "type_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ActionRequirementPayloadInputValueOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "key_ASC"
  | "key_DESC"
  | "eqValue_ASC"
  | "eqValue_DESC"
  | "neqValue_ASC"
  | "neqValue_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type EntityInstanceFieldOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "value_ASC"
  | "value_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type EntityInstanceStateOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type EntityInstanceStateTransitionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ActionPayloadInputValueOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "key_ASC"
  | "key_DESC"
  | "value_ASC"
  | "value_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ActionPayloadOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ActionRequirementPayloadOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ActionRequirementPayloadEntityOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type EntityOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "description_ASC"
  | "description_DESC"
  | "isTrigger_ASC"
  | "isTrigger_DESC"
  | "isItem_ASC"
  | "isItem_DESC"
  | "isObject_ASC"
  | "isObject_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "name_ASC"
  | "name_DESC"
  | "slug_ASC"
  | "slug_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type ActionWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface GameWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  slug?: String;
  slug_not?: String;
  slug_in?: String[] | String;
  slug_not_in?: String[] | String;
  slug_lt?: String;
  slug_lte?: String;
  slug_gt?: String;
  slug_gte?: String;
  slug_contains?: String;
  slug_not_contains?: String;
  slug_starts_with?: String;
  slug_not_starts_with?: String;
  slug_ends_with?: String;
  slug_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  creator?: UserWhereInput;
  instances_every?: EntityInstanceWhereInput;
  instances_some?: EntityInstanceWhereInput;
  instances_none?: EntityInstanceWhereInput;
  plays_every?: GamePlayWhereInput;
  plays_some?: GamePlayWhereInput;
  plays_none?: GamePlayWhereInput;
  AND?: GameWhereInput[] | GameWhereInput;
  OR?: GameWhereInput[] | GameWhereInput;
  NOT?: GameWhereInput[] | GameWhereInput;
}

export interface UserWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  slug?: String;
  slug_not?: String;
  slug_in?: String[] | String;
  slug_not_in?: String[] | String;
  slug_lt?: String;
  slug_lte?: String;
  slug_gt?: String;
  slug_gte?: String;
  slug_contains?: String;
  slug_not_contains?: String;
  slug_starts_with?: String;
  slug_not_starts_with?: String;
  slug_ends_with?: String;
  slug_not_ends_with?: String;
  games_every?: GameWhereInput;
  games_some?: GameWhereInput;
  games_none?: GameWhereInput;
  plays_every?: GamePlayWhereInput;
  plays_some?: GamePlayWhereInput;
  plays_none?: GamePlayWhereInput;
  AND?: UserWhereInput[] | UserWhereInput;
  OR?: UserWhereInput[] | UserWhereInput;
  NOT?: UserWhereInput[] | UserWhereInput;
}

export interface GamePlayWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  game?: GameWhereInput;
  player?: UserWhereInput;
  actions_every?: ActionWhereInput;
  actions_some?: ActionWhereInput;
  actions_none?: ActionWhereInput;
  AND?: GamePlayWhereInput[] | GamePlayWhereInput;
  OR?: GamePlayWhereInput[] | GamePlayWhereInput;
  NOT?: GamePlayWhereInput[] | GamePlayWhereInput;
}

export interface ActionWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  type?: ActionType;
  type_not?: ActionType;
  type_in?: ActionType[] | ActionType;
  type_not_in?: ActionType[] | ActionType;
  payload?: ActionPayloadWhereInput;
  gamePlay?: GamePlayWhereInput;
  AND?: ActionWhereInput[] | ActionWhereInput;
  OR?: ActionWhereInput[] | ActionWhereInput;
  NOT?: ActionWhereInput[] | ActionWhereInput;
}

export interface ActionPayloadWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  instance?: EntityInstanceWhereInput;
  state?: EntityStateWhereInput;
  item?: EntityInstanceWhereInput;
  inputValues_every?: ActionPayloadInputValueWhereInput;
  inputValues_some?: ActionPayloadInputValueWhereInput;
  inputValues_none?: ActionPayloadInputValueWhereInput;
  action?: ActionWhereInput;
  AND?: ActionPayloadWhereInput[] | ActionPayloadWhereInput;
  OR?: ActionPayloadWhereInput[] | ActionPayloadWhereInput;
  NOT?: ActionPayloadWhereInput[] | ActionPayloadWhereInput;
}

export interface EntityInstanceWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  game?: GameWhereInput;
  entity?: EntityWhereInput;
  fields_every?: EntityInstanceFieldWhereInput;
  fields_some?: EntityInstanceFieldWhereInput;
  fields_none?: EntityInstanceFieldWhereInput;
  states_every?: EntityInstanceStateWhereInput;
  states_some?: EntityInstanceStateWhereInput;
  states_none?: EntityInstanceStateWhereInput;
  AND?: EntityInstanceWhereInput[] | EntityInstanceWhereInput;
  OR?: EntityInstanceWhereInput[] | EntityInstanceWhereInput;
  NOT?: EntityInstanceWhereInput[] | EntityInstanceWhereInput;
}

export interface EntityWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  isTrigger?: Boolean;
  isTrigger_not?: Boolean;
  isItem?: Boolean;
  isItem_not?: Boolean;
  isObject?: Boolean;
  isObject_not?: Boolean;
  fields_every?: EntityFieldWhereInput;
  fields_some?: EntityFieldWhereInput;
  fields_none?: EntityFieldWhereInput;
  states_every?: EntityStateWhereInput;
  states_some?: EntityStateWhereInput;
  states_none?: EntityStateWhereInput;
  defaultState?: EntityStateWhereInput;
  instances_every?: EntityInstanceWhereInput;
  instances_some?: EntityInstanceWhereInput;
  instances_none?: EntityInstanceWhereInput;
  AND?: EntityWhereInput[] | EntityWhereInput;
  OR?: EntityWhereInput[] | EntityWhereInput;
  NOT?: EntityWhereInput[] | EntityWhereInput;
}

export interface EntityFieldWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  info?: String;
  info_not?: String;
  info_in?: String[] | String;
  info_not_in?: String[] | String;
  info_lt?: String;
  info_lte?: String;
  info_gt?: String;
  info_gte?: String;
  info_contains?: String;
  info_not_contains?: String;
  info_starts_with?: String;
  info_not_starts_with?: String;
  info_ends_with?: String;
  info_not_ends_with?: String;
  label?: String;
  label_not?: String;
  label_in?: String[] | String;
  label_not_in?: String[] | String;
  label_lt?: String;
  label_lte?: String;
  label_gt?: String;
  label_gte?: String;
  label_contains?: String;
  label_not_contains?: String;
  label_starts_with?: String;
  label_not_starts_with?: String;
  label_ends_with?: String;
  label_not_ends_with?: String;
  type?: FieldType;
  type_not?: FieldType;
  type_in?: FieldType[] | FieldType;
  type_not_in?: FieldType[] | FieldType;
  isMulti?: Boolean;
  isMulti_not?: Boolean;
  isSecret?: Boolean;
  isSecret_not?: Boolean;
  entity?: EntityWhereInput;
  AND?: EntityFieldWhereInput[] | EntityFieldWhereInput;
  OR?: EntityFieldWhereInput[] | EntityFieldWhereInput;
  NOT?: EntityFieldWhereInput[] | EntityFieldWhereInput;
}

export interface EntityStateWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  outgoingTransitions_every?: EntityStateTransitionWhereInput;
  outgoingTransitions_some?: EntityStateTransitionWhereInput;
  outgoingTransitions_none?: EntityStateTransitionWhereInput;
  incomingTransitions_every?: EntityStateTransitionWhereInput;
  incomingTransitions_some?: EntityStateTransitionWhereInput;
  incomingTransitions_none?: EntityStateTransitionWhereInput;
  entity?: EntityWhereInput;
  AND?: EntityStateWhereInput[] | EntityStateWhereInput;
  OR?: EntityStateWhereInput[] | EntityStateWhereInput;
  NOT?: EntityStateWhereInput[] | EntityStateWhereInput;
}

export interface EntityStateTransitionWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  requiredActions_every?: ActionRequirementWhereInput;
  requiredActions_some?: ActionRequirementWhereInput;
  requiredActions_none?: ActionRequirementWhereInput;
  from?: EntityStateWhereInput;
  to?: EntityStateWhereInput;
  AND?: EntityStateTransitionWhereInput[] | EntityStateTransitionWhereInput;
  OR?: EntityStateTransitionWhereInput[] | EntityStateTransitionWhereInput;
  NOT?: EntityStateTransitionWhereInput[] | EntityStateTransitionWhereInput;
}

export interface ActionRequirementWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  type?: ActionType;
  type_not?: ActionType;
  type_in?: ActionType[] | ActionType;
  type_not_in?: ActionType[] | ActionType;
  payload?: ActionRequirementPayloadWhereInput;
  AND?: ActionRequirementWhereInput[] | ActionRequirementWhereInput;
  OR?: ActionRequirementWhereInput[] | ActionRequirementWhereInput;
  NOT?: ActionRequirementWhereInput[] | ActionRequirementWhereInput;
}

export interface ActionRequirementPayloadWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  requiredEntity?: ActionRequirementPayloadEntityWhereInput;
  requiredValues_every?: ActionRequirementPayloadInputValueWhereInput;
  requiredValues_some?: ActionRequirementPayloadInputValueWhereInput;
  requiredValues_none?: ActionRequirementPayloadInputValueWhereInput;
  actionRequirement?: ActionRequirementWhereInput;
  AND?:
    | ActionRequirementPayloadWhereInput[]
    | ActionRequirementPayloadWhereInput;
  OR?:
    | ActionRequirementPayloadWhereInput[]
    | ActionRequirementPayloadWhereInput;
  NOT?:
    | ActionRequirementPayloadWhereInput[]
    | ActionRequirementPayloadWhereInput;
}

export interface ActionRequirementPayloadEntityWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  entity?: EntityWhereInput;
  state?: EntityStateWhereInput;
  payload?: ActionRequirementPayloadWhereInput;
  AND?:
    | ActionRequirementPayloadEntityWhereInput[]
    | ActionRequirementPayloadEntityWhereInput;
  OR?:
    | ActionRequirementPayloadEntityWhereInput[]
    | ActionRequirementPayloadEntityWhereInput;
  NOT?:
    | ActionRequirementPayloadEntityWhereInput[]
    | ActionRequirementPayloadEntityWhereInput;
}

export interface ActionRequirementPayloadInputValueWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  key?: String;
  key_not?: String;
  key_in?: String[] | String;
  key_not_in?: String[] | String;
  key_lt?: String;
  key_lte?: String;
  key_gt?: String;
  key_gte?: String;
  key_contains?: String;
  key_not_contains?: String;
  key_starts_with?: String;
  key_not_starts_with?: String;
  key_ends_with?: String;
  key_not_ends_with?: String;
  eqField?: EntityFieldWhereInput;
  neqField?: EntityFieldWhereInput;
  eqValue?: String;
  eqValue_not?: String;
  eqValue_in?: String[] | String;
  eqValue_not_in?: String[] | String;
  eqValue_lt?: String;
  eqValue_lte?: String;
  eqValue_gt?: String;
  eqValue_gte?: String;
  eqValue_contains?: String;
  eqValue_not_contains?: String;
  eqValue_starts_with?: String;
  eqValue_not_starts_with?: String;
  eqValue_ends_with?: String;
  eqValue_not_ends_with?: String;
  neqValue?: String;
  neqValue_not?: String;
  neqValue_in?: String[] | String;
  neqValue_not_in?: String[] | String;
  neqValue_lt?: String;
  neqValue_lte?: String;
  neqValue_gt?: String;
  neqValue_gte?: String;
  neqValue_contains?: String;
  neqValue_not_contains?: String;
  neqValue_starts_with?: String;
  neqValue_not_starts_with?: String;
  neqValue_ends_with?: String;
  neqValue_not_ends_with?: String;
  payload?: ActionRequirementPayloadWhereInput;
  AND?:
    | ActionRequirementPayloadInputValueWhereInput[]
    | ActionRequirementPayloadInputValueWhereInput;
  OR?:
    | ActionRequirementPayloadInputValueWhereInput[]
    | ActionRequirementPayloadInputValueWhereInput;
  NOT?:
    | ActionRequirementPayloadInputValueWhereInput[]
    | ActionRequirementPayloadInputValueWhereInput;
}

export interface EntityInstanceFieldWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  field?: EntityFieldWhereInput;
  value?: String;
  value_not?: String;
  value_in?: String[] | String;
  value_not_in?: String[] | String;
  value_lt?: String;
  value_lte?: String;
  value_gt?: String;
  value_gte?: String;
  value_contains?: String;
  value_not_contains?: String;
  value_starts_with?: String;
  value_not_starts_with?: String;
  value_ends_with?: String;
  value_not_ends_with?: String;
  AND?: EntityInstanceFieldWhereInput[] | EntityInstanceFieldWhereInput;
  OR?: EntityInstanceFieldWhereInput[] | EntityInstanceFieldWhereInput;
  NOT?: EntityInstanceFieldWhereInput[] | EntityInstanceFieldWhereInput;
}

export interface EntityInstanceStateWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  state?: EntityStateWhereInput;
  outgoingTransitions_every?: EntityInstanceStateTransitionWhereInput;
  outgoingTransitions_some?: EntityInstanceStateTransitionWhereInput;
  outgoingTransitions_none?: EntityInstanceStateTransitionWhereInput;
  incomingTransitions_every?: EntityInstanceStateTransitionWhereInput;
  incomingTransitions_some?: EntityInstanceStateTransitionWhereInput;
  incomingTransitions_none?: EntityInstanceStateTransitionWhereInput;
  unlockedBy?: EntityInstanceStateTransitionWhereInput;
  instance?: EntityInstanceWhereInput;
  AND?: EntityInstanceStateWhereInput[] | EntityInstanceStateWhereInput;
  OR?: EntityInstanceStateWhereInput[] | EntityInstanceStateWhereInput;
  NOT?: EntityInstanceStateWhereInput[] | EntityInstanceStateWhereInput;
}

export interface EntityInstanceStateTransitionWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  from?: EntityInstanceStateWhereInput;
  to?: EntityInstanceStateWhereInput;
  unlocks_every?: EntityInstanceStateWhereInput;
  unlocks_some?: EntityInstanceStateWhereInput;
  unlocks_none?: EntityInstanceStateWhereInput;
  AND?:
    | EntityInstanceStateTransitionWhereInput[]
    | EntityInstanceStateTransitionWhereInput;
  OR?:
    | EntityInstanceStateTransitionWhereInput[]
    | EntityInstanceStateTransitionWhereInput;
  NOT?:
    | EntityInstanceStateTransitionWhereInput[]
    | EntityInstanceStateTransitionWhereInput;
}

export interface ActionPayloadInputValueWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  key?: String;
  key_not?: String;
  key_in?: String[] | String;
  key_not_in?: String[] | String;
  key_lt?: String;
  key_lte?: String;
  key_gt?: String;
  key_gte?: String;
  key_contains?: String;
  key_not_contains?: String;
  key_starts_with?: String;
  key_not_starts_with?: String;
  key_ends_with?: String;
  key_not_ends_with?: String;
  value?: String;
  value_not?: String;
  value_in?: String[] | String;
  value_not_in?: String[] | String;
  value_lt?: String;
  value_lte?: String;
  value_gt?: String;
  value_gte?: String;
  value_contains?: String;
  value_not_contains?: String;
  value_starts_with?: String;
  value_not_starts_with?: String;
  value_ends_with?: String;
  value_not_ends_with?: String;
  AND?: ActionPayloadInputValueWhereInput[] | ActionPayloadInputValueWhereInput;
  OR?: ActionPayloadInputValueWhereInput[] | ActionPayloadInputValueWhereInput;
  NOT?: ActionPayloadInputValueWhereInput[] | ActionPayloadInputValueWhereInput;
}

export type ActionPayloadWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type ActionPayloadInputValueWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type ActionRequirementWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type ActionRequirementPayloadWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type ActionRequirementPayloadEntityWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type ActionRequirementPayloadInputValueWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type EntityWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type EntityFieldWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type EntityInstanceWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type EntityInstanceFieldWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type EntityInstanceStateWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type EntityInstanceStateTransitionWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type EntityStateWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type EntityStateTransitionWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type GameWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type GamePlayWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type UserWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ActionCreateInput {
  type: ActionType;
  payload: ActionPayloadCreateOneWithoutActionInput;
  gamePlay: GamePlayCreateOneWithoutActionsInput;
}

export interface ActionPayloadCreateOneWithoutActionInput {
  create?: ActionPayloadCreateWithoutActionInput;
  connect?: ActionPayloadWhereUniqueInput;
}

export interface ActionPayloadCreateWithoutActionInput {
  instance?: EntityInstanceCreateOneInput;
  state?: EntityStateCreateOneInput;
  item?: EntityInstanceCreateOneInput;
  inputValues?: ActionPayloadInputValueCreateManyInput;
}

export interface EntityInstanceCreateOneInput {
  create?: EntityInstanceCreateInput;
  connect?: EntityInstanceWhereUniqueInput;
}

export interface EntityInstanceCreateInput {
  name?: String;
  description?: String;
  game: GameCreateOneWithoutInstancesInput;
  entity: EntityCreateOneWithoutInstancesInput;
  fields?: EntityInstanceFieldCreateManyInput;
  states?: EntityInstanceStateCreateManyWithoutInstanceInput;
}

export interface GameCreateOneWithoutInstancesInput {
  create?: GameCreateWithoutInstancesInput;
  connect?: GameWhereUniqueInput;
}

export interface GameCreateWithoutInstancesInput {
  name: String;
  slug: String;
  description?: String;
  creator?: UserCreateOneWithoutGamesInput;
  plays?: GamePlayCreateManyWithoutGameInput;
}

export interface UserCreateOneWithoutGamesInput {
  create?: UserCreateWithoutGamesInput;
  connect?: UserWhereUniqueInput;
}

export interface UserCreateWithoutGamesInput {
  name: String;
  slug: String;
  plays?: GamePlayCreateManyWithoutPlayerInput;
}

export interface GamePlayCreateManyWithoutPlayerInput {
  create?:
    | GamePlayCreateWithoutPlayerInput[]
    | GamePlayCreateWithoutPlayerInput;
  connect?: GamePlayWhereUniqueInput[] | GamePlayWhereUniqueInput;
}

export interface GamePlayCreateWithoutPlayerInput {
  game: GameCreateOneWithoutPlaysInput;
  actions?: ActionCreateManyWithoutGamePlayInput;
}

export interface GameCreateOneWithoutPlaysInput {
  create?: GameCreateWithoutPlaysInput;
  connect?: GameWhereUniqueInput;
}

export interface GameCreateWithoutPlaysInput {
  name: String;
  slug: String;
  description?: String;
  creator?: UserCreateOneWithoutGamesInput;
  instances?: EntityInstanceCreateManyWithoutGameInput;
}

export interface EntityInstanceCreateManyWithoutGameInput {
  create?:
    | EntityInstanceCreateWithoutGameInput[]
    | EntityInstanceCreateWithoutGameInput;
  connect?: EntityInstanceWhereUniqueInput[] | EntityInstanceWhereUniqueInput;
}

export interface EntityInstanceCreateWithoutGameInput {
  name?: String;
  description?: String;
  entity: EntityCreateOneWithoutInstancesInput;
  fields?: EntityInstanceFieldCreateManyInput;
  states?: EntityInstanceStateCreateManyWithoutInstanceInput;
}

export interface EntityCreateOneWithoutInstancesInput {
  create?: EntityCreateWithoutInstancesInput;
  connect?: EntityWhereUniqueInput;
}

export interface EntityCreateWithoutInstancesInput {
  name: String;
  description?: String;
  isTrigger?: Boolean;
  isItem?: Boolean;
  isObject?: Boolean;
  fields?: EntityFieldCreateManyWithoutEntityInput;
  states?: EntityStateCreateManyWithoutEntityInput;
  defaultState?: EntityStateCreateOneInput;
}

export interface EntityFieldCreateManyWithoutEntityInput {
  create?:
    | EntityFieldCreateWithoutEntityInput[]
    | EntityFieldCreateWithoutEntityInput;
  connect?: EntityFieldWhereUniqueInput[] | EntityFieldWhereUniqueInput;
}

export interface EntityFieldCreateWithoutEntityInput {
  info?: String;
  label: String;
  type?: FieldType;
  isMulti?: Boolean;
  isSecret?: Boolean;
}

export interface EntityStateCreateManyWithoutEntityInput {
  create?:
    | EntityStateCreateWithoutEntityInput[]
    | EntityStateCreateWithoutEntityInput;
  connect?: EntityStateWhereUniqueInput[] | EntityStateWhereUniqueInput;
}

export interface EntityStateCreateWithoutEntityInput {
  name?: String;
  description?: String;
  outgoingTransitions?: EntityStateTransitionCreateManyWithoutFromInput;
  incomingTransitions?: EntityStateTransitionCreateManyWithoutToInput;
}

export interface EntityStateTransitionCreateManyWithoutFromInput {
  create?:
    | EntityStateTransitionCreateWithoutFromInput[]
    | EntityStateTransitionCreateWithoutFromInput;
  connect?:
    | EntityStateTransitionWhereUniqueInput[]
    | EntityStateTransitionWhereUniqueInput;
}

export interface EntityStateTransitionCreateWithoutFromInput {
  requiredActions?: ActionRequirementCreateManyInput;
  to?: EntityStateCreateOneWithoutIncomingTransitionsInput;
}

export interface ActionRequirementCreateManyInput {
  create?: ActionRequirementCreateInput[] | ActionRequirementCreateInput;
  connect?:
    | ActionRequirementWhereUniqueInput[]
    | ActionRequirementWhereUniqueInput;
}

export interface ActionRequirementCreateInput {
  type?: ActionType;
  hints?: ActionRequirementCreatehintsInput;
  payload: ActionRequirementPayloadCreateOneWithoutActionRequirementInput;
}

export interface ActionRequirementCreatehintsInput {
  set?: String[] | String;
}

export interface ActionRequirementPayloadCreateOneWithoutActionRequirementInput {
  create?: ActionRequirementPayloadCreateWithoutActionRequirementInput;
  connect?: ActionRequirementPayloadWhereUniqueInput;
}

export interface ActionRequirementPayloadCreateWithoutActionRequirementInput {
  requiredEntity?: ActionRequirementPayloadEntityCreateOneWithoutPayloadInput;
  requiredValues?: ActionRequirementPayloadInputValueCreateManyWithoutPayloadInput;
}

export interface ActionRequirementPayloadEntityCreateOneWithoutPayloadInput {
  create?: ActionRequirementPayloadEntityCreateWithoutPayloadInput;
  connect?: ActionRequirementPayloadEntityWhereUniqueInput;
}

export interface ActionRequirementPayloadEntityCreateWithoutPayloadInput {
  entity: EntityCreateOneInput;
  state: EntityStateCreateOneInput;
}

export interface EntityCreateOneInput {
  create?: EntityCreateInput;
  connect?: EntityWhereUniqueInput;
}

export interface EntityCreateInput {
  name: String;
  description?: String;
  isTrigger?: Boolean;
  isItem?: Boolean;
  isObject?: Boolean;
  fields?: EntityFieldCreateManyWithoutEntityInput;
  states?: EntityStateCreateManyWithoutEntityInput;
  defaultState?: EntityStateCreateOneInput;
  instances?: EntityInstanceCreateManyWithoutEntityInput;
}

export interface EntityStateCreateOneInput {
  create?: EntityStateCreateInput;
  connect?: EntityStateWhereUniqueInput;
}

export interface EntityStateCreateInput {
  name?: String;
  description?: String;
  outgoingTransitions?: EntityStateTransitionCreateManyWithoutFromInput;
  incomingTransitions?: EntityStateTransitionCreateManyWithoutToInput;
  entity: EntityCreateOneWithoutStatesInput;
}

export interface EntityStateTransitionCreateManyWithoutToInput {
  create?:
    | EntityStateTransitionCreateWithoutToInput[]
    | EntityStateTransitionCreateWithoutToInput;
  connect?:
    | EntityStateTransitionWhereUniqueInput[]
    | EntityStateTransitionWhereUniqueInput;
}

export interface EntityStateTransitionCreateWithoutToInput {
  requiredActions?: ActionRequirementCreateManyInput;
  from: EntityStateCreateOneWithoutOutgoingTransitionsInput;
}

export interface EntityStateCreateOneWithoutOutgoingTransitionsInput {
  create?: EntityStateCreateWithoutOutgoingTransitionsInput;
  connect?: EntityStateWhereUniqueInput;
}

export interface EntityStateCreateWithoutOutgoingTransitionsInput {
  name?: String;
  description?: String;
  incomingTransitions?: EntityStateTransitionCreateManyWithoutToInput;
  entity: EntityCreateOneWithoutStatesInput;
}

export interface EntityCreateOneWithoutStatesInput {
  create?: EntityCreateWithoutStatesInput;
  connect?: EntityWhereUniqueInput;
}

export interface EntityCreateWithoutStatesInput {
  name: String;
  description?: String;
  isTrigger?: Boolean;
  isItem?: Boolean;
  isObject?: Boolean;
  fields?: EntityFieldCreateManyWithoutEntityInput;
  defaultState?: EntityStateCreateOneInput;
  instances?: EntityInstanceCreateManyWithoutEntityInput;
}

export interface EntityInstanceCreateManyWithoutEntityInput {
  create?:
    | EntityInstanceCreateWithoutEntityInput[]
    | EntityInstanceCreateWithoutEntityInput;
  connect?: EntityInstanceWhereUniqueInput[] | EntityInstanceWhereUniqueInput;
}

export interface EntityInstanceCreateWithoutEntityInput {
  name?: String;
  description?: String;
  game: GameCreateOneWithoutInstancesInput;
  fields?: EntityInstanceFieldCreateManyInput;
  states?: EntityInstanceStateCreateManyWithoutInstanceInput;
}

export interface EntityInstanceFieldCreateManyInput {
  create?: EntityInstanceFieldCreateInput[] | EntityInstanceFieldCreateInput;
  connect?:
    | EntityInstanceFieldWhereUniqueInput[]
    | EntityInstanceFieldWhereUniqueInput;
}

export interface EntityInstanceFieldCreateInput {
  field: EntityFieldCreateOneInput;
  value?: String;
}

export interface EntityFieldCreateOneInput {
  create?: EntityFieldCreateInput;
  connect?: EntityFieldWhereUniqueInput;
}

export interface EntityFieldCreateInput {
  info?: String;
  label: String;
  type?: FieldType;
  isMulti?: Boolean;
  isSecret?: Boolean;
  entity: EntityCreateOneWithoutFieldsInput;
}

export interface EntityCreateOneWithoutFieldsInput {
  create?: EntityCreateWithoutFieldsInput;
  connect?: EntityWhereUniqueInput;
}

export interface EntityCreateWithoutFieldsInput {
  name: String;
  description?: String;
  isTrigger?: Boolean;
  isItem?: Boolean;
  isObject?: Boolean;
  states?: EntityStateCreateManyWithoutEntityInput;
  defaultState?: EntityStateCreateOneInput;
  instances?: EntityInstanceCreateManyWithoutEntityInput;
}

export interface EntityInstanceStateCreateManyWithoutInstanceInput {
  create?:
    | EntityInstanceStateCreateWithoutInstanceInput[]
    | EntityInstanceStateCreateWithoutInstanceInput;
  connect?:
    | EntityInstanceStateWhereUniqueInput[]
    | EntityInstanceStateWhereUniqueInput;
}

export interface EntityInstanceStateCreateWithoutInstanceInput {
  state: EntityStateCreateOneInput;
  outgoingTransitions?: EntityInstanceStateTransitionCreateManyWithoutFromInput;
  incomingTransitions?: EntityInstanceStateTransitionCreateManyWithoutToInput;
  unlockedBy?: EntityInstanceStateTransitionCreateOneWithoutUnlocksInput;
}

export interface EntityInstanceStateTransitionCreateManyWithoutFromInput {
  create?:
    | EntityInstanceStateTransitionCreateWithoutFromInput[]
    | EntityInstanceStateTransitionCreateWithoutFromInput;
  connect?:
    | EntityInstanceStateTransitionWhereUniqueInput[]
    | EntityInstanceStateTransitionWhereUniqueInput;
}

export interface EntityInstanceStateTransitionCreateWithoutFromInput {
  to?: EntityInstanceStateCreateOneWithoutIncomingTransitionsInput;
  unlocks?: EntityInstanceStateCreateManyWithoutUnlockedByInput;
}

export interface EntityInstanceStateCreateOneWithoutIncomingTransitionsInput {
  create?: EntityInstanceStateCreateWithoutIncomingTransitionsInput;
  connect?: EntityInstanceStateWhereUniqueInput;
}

export interface EntityInstanceStateCreateWithoutIncomingTransitionsInput {
  state: EntityStateCreateOneInput;
  outgoingTransitions?: EntityInstanceStateTransitionCreateManyWithoutFromInput;
  unlockedBy?: EntityInstanceStateTransitionCreateOneWithoutUnlocksInput;
  instance: EntityInstanceCreateOneWithoutStatesInput;
}

export interface EntityInstanceStateTransitionCreateOneWithoutUnlocksInput {
  create?: EntityInstanceStateTransitionCreateWithoutUnlocksInput;
  connect?: EntityInstanceStateTransitionWhereUniqueInput;
}

export interface EntityInstanceStateTransitionCreateWithoutUnlocksInput {
  from: EntityInstanceStateCreateOneWithoutOutgoingTransitionsInput;
  to?: EntityInstanceStateCreateOneWithoutIncomingTransitionsInput;
}

export interface EntityInstanceStateCreateOneWithoutOutgoingTransitionsInput {
  create?: EntityInstanceStateCreateWithoutOutgoingTransitionsInput;
  connect?: EntityInstanceStateWhereUniqueInput;
}

export interface EntityInstanceStateCreateWithoutOutgoingTransitionsInput {
  state: EntityStateCreateOneInput;
  incomingTransitions?: EntityInstanceStateTransitionCreateManyWithoutToInput;
  unlockedBy?: EntityInstanceStateTransitionCreateOneWithoutUnlocksInput;
  instance: EntityInstanceCreateOneWithoutStatesInput;
}

export interface EntityInstanceStateTransitionCreateManyWithoutToInput {
  create?:
    | EntityInstanceStateTransitionCreateWithoutToInput[]
    | EntityInstanceStateTransitionCreateWithoutToInput;
  connect?:
    | EntityInstanceStateTransitionWhereUniqueInput[]
    | EntityInstanceStateTransitionWhereUniqueInput;
}

export interface EntityInstanceStateTransitionCreateWithoutToInput {
  from: EntityInstanceStateCreateOneWithoutOutgoingTransitionsInput;
  unlocks?: EntityInstanceStateCreateManyWithoutUnlockedByInput;
}

export interface EntityInstanceStateCreateManyWithoutUnlockedByInput {
  create?:
    | EntityInstanceStateCreateWithoutUnlockedByInput[]
    | EntityInstanceStateCreateWithoutUnlockedByInput;
  connect?:
    | EntityInstanceStateWhereUniqueInput[]
    | EntityInstanceStateWhereUniqueInput;
}

export interface EntityInstanceStateCreateWithoutUnlockedByInput {
  state: EntityStateCreateOneInput;
  outgoingTransitions?: EntityInstanceStateTransitionCreateManyWithoutFromInput;
  incomingTransitions?: EntityInstanceStateTransitionCreateManyWithoutToInput;
  instance: EntityInstanceCreateOneWithoutStatesInput;
}

export interface EntityInstanceCreateOneWithoutStatesInput {
  create?: EntityInstanceCreateWithoutStatesInput;
  connect?: EntityInstanceWhereUniqueInput;
}

export interface EntityInstanceCreateWithoutStatesInput {
  name?: String;
  description?: String;
  game: GameCreateOneWithoutInstancesInput;
  entity: EntityCreateOneWithoutInstancesInput;
  fields?: EntityInstanceFieldCreateManyInput;
}

export interface ActionRequirementPayloadInputValueCreateManyWithoutPayloadInput {
  create?:
    | ActionRequirementPayloadInputValueCreateWithoutPayloadInput[]
    | ActionRequirementPayloadInputValueCreateWithoutPayloadInput;
  connect?:
    | ActionRequirementPayloadInputValueWhereUniqueInput[]
    | ActionRequirementPayloadInputValueWhereUniqueInput;
}

export interface ActionRequirementPayloadInputValueCreateWithoutPayloadInput {
  key: String;
  eqField?: EntityFieldCreateOneInput;
  neqField?: EntityFieldCreateOneInput;
  eqValue?: String;
  neqValue?: String;
}

export interface EntityStateCreateOneWithoutIncomingTransitionsInput {
  create?: EntityStateCreateWithoutIncomingTransitionsInput;
  connect?: EntityStateWhereUniqueInput;
}

export interface EntityStateCreateWithoutIncomingTransitionsInput {
  name?: String;
  description?: String;
  outgoingTransitions?: EntityStateTransitionCreateManyWithoutFromInput;
  entity: EntityCreateOneWithoutStatesInput;
}

export interface ActionCreateManyWithoutGamePlayInput {
  create?:
    | ActionCreateWithoutGamePlayInput[]
    | ActionCreateWithoutGamePlayInput;
  connect?: ActionWhereUniqueInput[] | ActionWhereUniqueInput;
}

export interface ActionCreateWithoutGamePlayInput {
  type: ActionType;
  payload: ActionPayloadCreateOneWithoutActionInput;
}

export interface GamePlayCreateManyWithoutGameInput {
  create?: GamePlayCreateWithoutGameInput[] | GamePlayCreateWithoutGameInput;
  connect?: GamePlayWhereUniqueInput[] | GamePlayWhereUniqueInput;
}

export interface GamePlayCreateWithoutGameInput {
  player?: UserCreateOneWithoutPlaysInput;
  actions?: ActionCreateManyWithoutGamePlayInput;
}

export interface UserCreateOneWithoutPlaysInput {
  create?: UserCreateWithoutPlaysInput;
  connect?: UserWhereUniqueInput;
}

export interface UserCreateWithoutPlaysInput {
  name: String;
  slug: String;
  games?: GameCreateManyWithoutCreatorInput;
}

export interface GameCreateManyWithoutCreatorInput {
  create?: GameCreateWithoutCreatorInput[] | GameCreateWithoutCreatorInput;
  connect?: GameWhereUniqueInput[] | GameWhereUniqueInput;
}

export interface GameCreateWithoutCreatorInput {
  name: String;
  slug: String;
  description?: String;
  instances?: EntityInstanceCreateManyWithoutGameInput;
  plays?: GamePlayCreateManyWithoutGameInput;
}

export interface ActionPayloadInputValueCreateManyInput {
  create?:
    | ActionPayloadInputValueCreateInput[]
    | ActionPayloadInputValueCreateInput;
  connect?:
    | ActionPayloadInputValueWhereUniqueInput[]
    | ActionPayloadInputValueWhereUniqueInput;
}

export interface ActionPayloadInputValueCreateInput {
  key: String;
  value?: String;
}

export interface GamePlayCreateOneWithoutActionsInput {
  create?: GamePlayCreateWithoutActionsInput;
  connect?: GamePlayWhereUniqueInput;
}

export interface GamePlayCreateWithoutActionsInput {
  game: GameCreateOneWithoutPlaysInput;
  player?: UserCreateOneWithoutPlaysInput;
}

export interface ActionUpdateInput {
  type?: ActionType;
  payload?: ActionPayloadUpdateOneRequiredWithoutActionInput;
  gamePlay?: GamePlayUpdateOneRequiredWithoutActionsInput;
}

export interface ActionPayloadUpdateOneRequiredWithoutActionInput {
  create?: ActionPayloadCreateWithoutActionInput;
  update?: ActionPayloadUpdateWithoutActionDataInput;
  upsert?: ActionPayloadUpsertWithoutActionInput;
  connect?: ActionPayloadWhereUniqueInput;
}

export interface ActionPayloadUpdateWithoutActionDataInput {
  instance?: EntityInstanceUpdateOneInput;
  state?: EntityStateUpdateOneInput;
  item?: EntityInstanceUpdateOneInput;
  inputValues?: ActionPayloadInputValueUpdateManyInput;
}

export interface EntityInstanceUpdateOneInput {
  create?: EntityInstanceCreateInput;
  update?: EntityInstanceUpdateDataInput;
  upsert?: EntityInstanceUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: EntityInstanceWhereUniqueInput;
}

export interface EntityInstanceUpdateDataInput {
  name?: String;
  description?: String;
  game?: GameUpdateOneRequiredWithoutInstancesInput;
  entity?: EntityUpdateOneRequiredWithoutInstancesInput;
  fields?: EntityInstanceFieldUpdateManyInput;
  states?: EntityInstanceStateUpdateManyWithoutInstanceInput;
}

export interface GameUpdateOneRequiredWithoutInstancesInput {
  create?: GameCreateWithoutInstancesInput;
  update?: GameUpdateWithoutInstancesDataInput;
  upsert?: GameUpsertWithoutInstancesInput;
  connect?: GameWhereUniqueInput;
}

export interface GameUpdateWithoutInstancesDataInput {
  name?: String;
  slug?: String;
  description?: String;
  creator?: UserUpdateOneWithoutGamesInput;
  plays?: GamePlayUpdateManyWithoutGameInput;
}

export interface UserUpdateOneWithoutGamesInput {
  create?: UserCreateWithoutGamesInput;
  update?: UserUpdateWithoutGamesDataInput;
  upsert?: UserUpsertWithoutGamesInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: UserWhereUniqueInput;
}

export interface UserUpdateWithoutGamesDataInput {
  name?: String;
  slug?: String;
  plays?: GamePlayUpdateManyWithoutPlayerInput;
}

export interface GamePlayUpdateManyWithoutPlayerInput {
  create?:
    | GamePlayCreateWithoutPlayerInput[]
    | GamePlayCreateWithoutPlayerInput;
  delete?: GamePlayWhereUniqueInput[] | GamePlayWhereUniqueInput;
  connect?: GamePlayWhereUniqueInput[] | GamePlayWhereUniqueInput;
  disconnect?: GamePlayWhereUniqueInput[] | GamePlayWhereUniqueInput;
  update?:
    | GamePlayUpdateWithWhereUniqueWithoutPlayerInput[]
    | GamePlayUpdateWithWhereUniqueWithoutPlayerInput;
  upsert?:
    | GamePlayUpsertWithWhereUniqueWithoutPlayerInput[]
    | GamePlayUpsertWithWhereUniqueWithoutPlayerInput;
  deleteMany?: GamePlayScalarWhereInput[] | GamePlayScalarWhereInput;
}

export interface GamePlayUpdateWithWhereUniqueWithoutPlayerInput {
  where: GamePlayWhereUniqueInput;
  data: GamePlayUpdateWithoutPlayerDataInput;
}

export interface GamePlayUpdateWithoutPlayerDataInput {
  game?: GameUpdateOneRequiredWithoutPlaysInput;
  actions?: ActionUpdateManyWithoutGamePlayInput;
}

export interface GameUpdateOneRequiredWithoutPlaysInput {
  create?: GameCreateWithoutPlaysInput;
  update?: GameUpdateWithoutPlaysDataInput;
  upsert?: GameUpsertWithoutPlaysInput;
  connect?: GameWhereUniqueInput;
}

export interface GameUpdateWithoutPlaysDataInput {
  name?: String;
  slug?: String;
  description?: String;
  creator?: UserUpdateOneWithoutGamesInput;
  instances?: EntityInstanceUpdateManyWithoutGameInput;
}

export interface EntityInstanceUpdateManyWithoutGameInput {
  create?:
    | EntityInstanceCreateWithoutGameInput[]
    | EntityInstanceCreateWithoutGameInput;
  delete?: EntityInstanceWhereUniqueInput[] | EntityInstanceWhereUniqueInput;
  connect?: EntityInstanceWhereUniqueInput[] | EntityInstanceWhereUniqueInput;
  disconnect?:
    | EntityInstanceWhereUniqueInput[]
    | EntityInstanceWhereUniqueInput;
  update?:
    | EntityInstanceUpdateWithWhereUniqueWithoutGameInput[]
    | EntityInstanceUpdateWithWhereUniqueWithoutGameInput;
  upsert?:
    | EntityInstanceUpsertWithWhereUniqueWithoutGameInput[]
    | EntityInstanceUpsertWithWhereUniqueWithoutGameInput;
  deleteMany?:
    | EntityInstanceScalarWhereInput[]
    | EntityInstanceScalarWhereInput;
  updateMany?:
    | EntityInstanceUpdateManyWithWhereNestedInput[]
    | EntityInstanceUpdateManyWithWhereNestedInput;
}

export interface EntityInstanceUpdateWithWhereUniqueWithoutGameInput {
  where: EntityInstanceWhereUniqueInput;
  data: EntityInstanceUpdateWithoutGameDataInput;
}

export interface EntityInstanceUpdateWithoutGameDataInput {
  name?: String;
  description?: String;
  entity?: EntityUpdateOneRequiredWithoutInstancesInput;
  fields?: EntityInstanceFieldUpdateManyInput;
  states?: EntityInstanceStateUpdateManyWithoutInstanceInput;
}

export interface EntityUpdateOneRequiredWithoutInstancesInput {
  create?: EntityCreateWithoutInstancesInput;
  update?: EntityUpdateWithoutInstancesDataInput;
  upsert?: EntityUpsertWithoutInstancesInput;
  connect?: EntityWhereUniqueInput;
}

export interface EntityUpdateWithoutInstancesDataInput {
  name?: String;
  description?: String;
  isTrigger?: Boolean;
  isItem?: Boolean;
  isObject?: Boolean;
  fields?: EntityFieldUpdateManyWithoutEntityInput;
  states?: EntityStateUpdateManyWithoutEntityInput;
  defaultState?: EntityStateUpdateOneInput;
}

export interface EntityFieldUpdateManyWithoutEntityInput {
  create?:
    | EntityFieldCreateWithoutEntityInput[]
    | EntityFieldCreateWithoutEntityInput;
  delete?: EntityFieldWhereUniqueInput[] | EntityFieldWhereUniqueInput;
  connect?: EntityFieldWhereUniqueInput[] | EntityFieldWhereUniqueInput;
  disconnect?: EntityFieldWhereUniqueInput[] | EntityFieldWhereUniqueInput;
  update?:
    | EntityFieldUpdateWithWhereUniqueWithoutEntityInput[]
    | EntityFieldUpdateWithWhereUniqueWithoutEntityInput;
  upsert?:
    | EntityFieldUpsertWithWhereUniqueWithoutEntityInput[]
    | EntityFieldUpsertWithWhereUniqueWithoutEntityInput;
  deleteMany?: EntityFieldScalarWhereInput[] | EntityFieldScalarWhereInput;
  updateMany?:
    | EntityFieldUpdateManyWithWhereNestedInput[]
    | EntityFieldUpdateManyWithWhereNestedInput;
}

export interface EntityFieldUpdateWithWhereUniqueWithoutEntityInput {
  where: EntityFieldWhereUniqueInput;
  data: EntityFieldUpdateWithoutEntityDataInput;
}

export interface EntityFieldUpdateWithoutEntityDataInput {
  info?: String;
  label?: String;
  type?: FieldType;
  isMulti?: Boolean;
  isSecret?: Boolean;
}

export interface EntityFieldUpsertWithWhereUniqueWithoutEntityInput {
  where: EntityFieldWhereUniqueInput;
  update: EntityFieldUpdateWithoutEntityDataInput;
  create: EntityFieldCreateWithoutEntityInput;
}

export interface EntityFieldScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  info?: String;
  info_not?: String;
  info_in?: String[] | String;
  info_not_in?: String[] | String;
  info_lt?: String;
  info_lte?: String;
  info_gt?: String;
  info_gte?: String;
  info_contains?: String;
  info_not_contains?: String;
  info_starts_with?: String;
  info_not_starts_with?: String;
  info_ends_with?: String;
  info_not_ends_with?: String;
  label?: String;
  label_not?: String;
  label_in?: String[] | String;
  label_not_in?: String[] | String;
  label_lt?: String;
  label_lte?: String;
  label_gt?: String;
  label_gte?: String;
  label_contains?: String;
  label_not_contains?: String;
  label_starts_with?: String;
  label_not_starts_with?: String;
  label_ends_with?: String;
  label_not_ends_with?: String;
  type?: FieldType;
  type_not?: FieldType;
  type_in?: FieldType[] | FieldType;
  type_not_in?: FieldType[] | FieldType;
  isMulti?: Boolean;
  isMulti_not?: Boolean;
  isSecret?: Boolean;
  isSecret_not?: Boolean;
  AND?: EntityFieldScalarWhereInput[] | EntityFieldScalarWhereInput;
  OR?: EntityFieldScalarWhereInput[] | EntityFieldScalarWhereInput;
  NOT?: EntityFieldScalarWhereInput[] | EntityFieldScalarWhereInput;
}

export interface EntityFieldUpdateManyWithWhereNestedInput {
  where: EntityFieldScalarWhereInput;
  data: EntityFieldUpdateManyDataInput;
}

export interface EntityFieldUpdateManyDataInput {
  info?: String;
  label?: String;
  type?: FieldType;
  isMulti?: Boolean;
  isSecret?: Boolean;
}

export interface EntityStateUpdateManyWithoutEntityInput {
  create?:
    | EntityStateCreateWithoutEntityInput[]
    | EntityStateCreateWithoutEntityInput;
  delete?: EntityStateWhereUniqueInput[] | EntityStateWhereUniqueInput;
  connect?: EntityStateWhereUniqueInput[] | EntityStateWhereUniqueInput;
  disconnect?: EntityStateWhereUniqueInput[] | EntityStateWhereUniqueInput;
  update?:
    | EntityStateUpdateWithWhereUniqueWithoutEntityInput[]
    | EntityStateUpdateWithWhereUniqueWithoutEntityInput;
  upsert?:
    | EntityStateUpsertWithWhereUniqueWithoutEntityInput[]
    | EntityStateUpsertWithWhereUniqueWithoutEntityInput;
  deleteMany?: EntityStateScalarWhereInput[] | EntityStateScalarWhereInput;
  updateMany?:
    | EntityStateUpdateManyWithWhereNestedInput[]
    | EntityStateUpdateManyWithWhereNestedInput;
}

export interface EntityStateUpdateWithWhereUniqueWithoutEntityInput {
  where: EntityStateWhereUniqueInput;
  data: EntityStateUpdateWithoutEntityDataInput;
}

export interface EntityStateUpdateWithoutEntityDataInput {
  name?: String;
  description?: String;
  outgoingTransitions?: EntityStateTransitionUpdateManyWithoutFromInput;
  incomingTransitions?: EntityStateTransitionUpdateManyWithoutToInput;
}

export interface EntityStateTransitionUpdateManyWithoutFromInput {
  create?:
    | EntityStateTransitionCreateWithoutFromInput[]
    | EntityStateTransitionCreateWithoutFromInput;
  delete?:
    | EntityStateTransitionWhereUniqueInput[]
    | EntityStateTransitionWhereUniqueInput;
  connect?:
    | EntityStateTransitionWhereUniqueInput[]
    | EntityStateTransitionWhereUniqueInput;
  disconnect?:
    | EntityStateTransitionWhereUniqueInput[]
    | EntityStateTransitionWhereUniqueInput;
  update?:
    | EntityStateTransitionUpdateWithWhereUniqueWithoutFromInput[]
    | EntityStateTransitionUpdateWithWhereUniqueWithoutFromInput;
  upsert?:
    | EntityStateTransitionUpsertWithWhereUniqueWithoutFromInput[]
    | EntityStateTransitionUpsertWithWhereUniqueWithoutFromInput;
  deleteMany?:
    | EntityStateTransitionScalarWhereInput[]
    | EntityStateTransitionScalarWhereInput;
}

export interface EntityStateTransitionUpdateWithWhereUniqueWithoutFromInput {
  where: EntityStateTransitionWhereUniqueInput;
  data: EntityStateTransitionUpdateWithoutFromDataInput;
}

export interface EntityStateTransitionUpdateWithoutFromDataInput {
  requiredActions?: ActionRequirementUpdateManyInput;
  to?: EntityStateUpdateOneWithoutIncomingTransitionsInput;
}

export interface ActionRequirementUpdateManyInput {
  create?: ActionRequirementCreateInput[] | ActionRequirementCreateInput;
  update?:
    | ActionRequirementUpdateWithWhereUniqueNestedInput[]
    | ActionRequirementUpdateWithWhereUniqueNestedInput;
  upsert?:
    | ActionRequirementUpsertWithWhereUniqueNestedInput[]
    | ActionRequirementUpsertWithWhereUniqueNestedInput;
  delete?:
    | ActionRequirementWhereUniqueInput[]
    | ActionRequirementWhereUniqueInput;
  connect?:
    | ActionRequirementWhereUniqueInput[]
    | ActionRequirementWhereUniqueInput;
  disconnect?:
    | ActionRequirementWhereUniqueInput[]
    | ActionRequirementWhereUniqueInput;
  deleteMany?:
    | ActionRequirementScalarWhereInput[]
    | ActionRequirementScalarWhereInput;
  updateMany?:
    | ActionRequirementUpdateManyWithWhereNestedInput[]
    | ActionRequirementUpdateManyWithWhereNestedInput;
}

export interface ActionRequirementUpdateWithWhereUniqueNestedInput {
  where: ActionRequirementWhereUniqueInput;
  data: ActionRequirementUpdateDataInput;
}

export interface ActionRequirementUpdateDataInput {
  type?: ActionType;
  hints?: ActionRequirementUpdatehintsInput;
  payload?: ActionRequirementPayloadUpdateOneRequiredWithoutActionRequirementInput;
}

export interface ActionRequirementUpdatehintsInput {
  set?: String[] | String;
}

export interface ActionRequirementPayloadUpdateOneRequiredWithoutActionRequirementInput {
  create?: ActionRequirementPayloadCreateWithoutActionRequirementInput;
  update?: ActionRequirementPayloadUpdateWithoutActionRequirementDataInput;
  upsert?: ActionRequirementPayloadUpsertWithoutActionRequirementInput;
  connect?: ActionRequirementPayloadWhereUniqueInput;
}

export interface ActionRequirementPayloadUpdateWithoutActionRequirementDataInput {
  requiredEntity?: ActionRequirementPayloadEntityUpdateOneWithoutPayloadInput;
  requiredValues?: ActionRequirementPayloadInputValueUpdateManyWithoutPayloadInput;
}

export interface ActionRequirementPayloadEntityUpdateOneWithoutPayloadInput {
  create?: ActionRequirementPayloadEntityCreateWithoutPayloadInput;
  update?: ActionRequirementPayloadEntityUpdateWithoutPayloadDataInput;
  upsert?: ActionRequirementPayloadEntityUpsertWithoutPayloadInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: ActionRequirementPayloadEntityWhereUniqueInput;
}

export interface ActionRequirementPayloadEntityUpdateWithoutPayloadDataInput {
  entity?: EntityUpdateOneRequiredInput;
  state?: EntityStateUpdateOneRequiredInput;
}

export interface EntityUpdateOneRequiredInput {
  create?: EntityCreateInput;
  update?: EntityUpdateDataInput;
  upsert?: EntityUpsertNestedInput;
  connect?: EntityWhereUniqueInput;
}

export interface EntityUpdateDataInput {
  name?: String;
  description?: String;
  isTrigger?: Boolean;
  isItem?: Boolean;
  isObject?: Boolean;
  fields?: EntityFieldUpdateManyWithoutEntityInput;
  states?: EntityStateUpdateManyWithoutEntityInput;
  defaultState?: EntityStateUpdateOneInput;
  instances?: EntityInstanceUpdateManyWithoutEntityInput;
}

export interface EntityStateUpdateOneInput {
  create?: EntityStateCreateInput;
  update?: EntityStateUpdateDataInput;
  upsert?: EntityStateUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: EntityStateWhereUniqueInput;
}

export interface EntityStateUpdateDataInput {
  name?: String;
  description?: String;
  outgoingTransitions?: EntityStateTransitionUpdateManyWithoutFromInput;
  incomingTransitions?: EntityStateTransitionUpdateManyWithoutToInput;
  entity?: EntityUpdateOneRequiredWithoutStatesInput;
}

export interface EntityStateTransitionUpdateManyWithoutToInput {
  create?:
    | EntityStateTransitionCreateWithoutToInput[]
    | EntityStateTransitionCreateWithoutToInput;
  delete?:
    | EntityStateTransitionWhereUniqueInput[]
    | EntityStateTransitionWhereUniqueInput;
  connect?:
    | EntityStateTransitionWhereUniqueInput[]
    | EntityStateTransitionWhereUniqueInput;
  disconnect?:
    | EntityStateTransitionWhereUniqueInput[]
    | EntityStateTransitionWhereUniqueInput;
  update?:
    | EntityStateTransitionUpdateWithWhereUniqueWithoutToInput[]
    | EntityStateTransitionUpdateWithWhereUniqueWithoutToInput;
  upsert?:
    | EntityStateTransitionUpsertWithWhereUniqueWithoutToInput[]
    | EntityStateTransitionUpsertWithWhereUniqueWithoutToInput;
  deleteMany?:
    | EntityStateTransitionScalarWhereInput[]
    | EntityStateTransitionScalarWhereInput;
}

export interface EntityStateTransitionUpdateWithWhereUniqueWithoutToInput {
  where: EntityStateTransitionWhereUniqueInput;
  data: EntityStateTransitionUpdateWithoutToDataInput;
}

export interface EntityStateTransitionUpdateWithoutToDataInput {
  requiredActions?: ActionRequirementUpdateManyInput;
  from?: EntityStateUpdateOneRequiredWithoutOutgoingTransitionsInput;
}

export interface EntityStateUpdateOneRequiredWithoutOutgoingTransitionsInput {
  create?: EntityStateCreateWithoutOutgoingTransitionsInput;
  update?: EntityStateUpdateWithoutOutgoingTransitionsDataInput;
  upsert?: EntityStateUpsertWithoutOutgoingTransitionsInput;
  connect?: EntityStateWhereUniqueInput;
}

export interface EntityStateUpdateWithoutOutgoingTransitionsDataInput {
  name?: String;
  description?: String;
  incomingTransitions?: EntityStateTransitionUpdateManyWithoutToInput;
  entity?: EntityUpdateOneRequiredWithoutStatesInput;
}

export interface EntityUpdateOneRequiredWithoutStatesInput {
  create?: EntityCreateWithoutStatesInput;
  update?: EntityUpdateWithoutStatesDataInput;
  upsert?: EntityUpsertWithoutStatesInput;
  connect?: EntityWhereUniqueInput;
}

export interface EntityUpdateWithoutStatesDataInput {
  name?: String;
  description?: String;
  isTrigger?: Boolean;
  isItem?: Boolean;
  isObject?: Boolean;
  fields?: EntityFieldUpdateManyWithoutEntityInput;
  defaultState?: EntityStateUpdateOneInput;
  instances?: EntityInstanceUpdateManyWithoutEntityInput;
}

export interface EntityInstanceUpdateManyWithoutEntityInput {
  create?:
    | EntityInstanceCreateWithoutEntityInput[]
    | EntityInstanceCreateWithoutEntityInput;
  delete?: EntityInstanceWhereUniqueInput[] | EntityInstanceWhereUniqueInput;
  connect?: EntityInstanceWhereUniqueInput[] | EntityInstanceWhereUniqueInput;
  disconnect?:
    | EntityInstanceWhereUniqueInput[]
    | EntityInstanceWhereUniqueInput;
  update?:
    | EntityInstanceUpdateWithWhereUniqueWithoutEntityInput[]
    | EntityInstanceUpdateWithWhereUniqueWithoutEntityInput;
  upsert?:
    | EntityInstanceUpsertWithWhereUniqueWithoutEntityInput[]
    | EntityInstanceUpsertWithWhereUniqueWithoutEntityInput;
  deleteMany?:
    | EntityInstanceScalarWhereInput[]
    | EntityInstanceScalarWhereInput;
  updateMany?:
    | EntityInstanceUpdateManyWithWhereNestedInput[]
    | EntityInstanceUpdateManyWithWhereNestedInput;
}

export interface EntityInstanceUpdateWithWhereUniqueWithoutEntityInput {
  where: EntityInstanceWhereUniqueInput;
  data: EntityInstanceUpdateWithoutEntityDataInput;
}

export interface EntityInstanceUpdateWithoutEntityDataInput {
  name?: String;
  description?: String;
  game?: GameUpdateOneRequiredWithoutInstancesInput;
  fields?: EntityInstanceFieldUpdateManyInput;
  states?: EntityInstanceStateUpdateManyWithoutInstanceInput;
}

export interface EntityInstanceFieldUpdateManyInput {
  create?: EntityInstanceFieldCreateInput[] | EntityInstanceFieldCreateInput;
  update?:
    | EntityInstanceFieldUpdateWithWhereUniqueNestedInput[]
    | EntityInstanceFieldUpdateWithWhereUniqueNestedInput;
  upsert?:
    | EntityInstanceFieldUpsertWithWhereUniqueNestedInput[]
    | EntityInstanceFieldUpsertWithWhereUniqueNestedInput;
  delete?:
    | EntityInstanceFieldWhereUniqueInput[]
    | EntityInstanceFieldWhereUniqueInput;
  connect?:
    | EntityInstanceFieldWhereUniqueInput[]
    | EntityInstanceFieldWhereUniqueInput;
  disconnect?:
    | EntityInstanceFieldWhereUniqueInput[]
    | EntityInstanceFieldWhereUniqueInput;
  deleteMany?:
    | EntityInstanceFieldScalarWhereInput[]
    | EntityInstanceFieldScalarWhereInput;
  updateMany?:
    | EntityInstanceFieldUpdateManyWithWhereNestedInput[]
    | EntityInstanceFieldUpdateManyWithWhereNestedInput;
}

export interface EntityInstanceFieldUpdateWithWhereUniqueNestedInput {
  where: EntityInstanceFieldWhereUniqueInput;
  data: EntityInstanceFieldUpdateDataInput;
}

export interface EntityInstanceFieldUpdateDataInput {
  field?: EntityFieldUpdateOneRequiredInput;
  value?: String;
}

export interface EntityFieldUpdateOneRequiredInput {
  create?: EntityFieldCreateInput;
  update?: EntityFieldUpdateDataInput;
  upsert?: EntityFieldUpsertNestedInput;
  connect?: EntityFieldWhereUniqueInput;
}

export interface EntityFieldUpdateDataInput {
  info?: String;
  label?: String;
  type?: FieldType;
  isMulti?: Boolean;
  isSecret?: Boolean;
  entity?: EntityUpdateOneRequiredWithoutFieldsInput;
}

export interface EntityUpdateOneRequiredWithoutFieldsInput {
  create?: EntityCreateWithoutFieldsInput;
  update?: EntityUpdateWithoutFieldsDataInput;
  upsert?: EntityUpsertWithoutFieldsInput;
  connect?: EntityWhereUniqueInput;
}

export interface EntityUpdateWithoutFieldsDataInput {
  name?: String;
  description?: String;
  isTrigger?: Boolean;
  isItem?: Boolean;
  isObject?: Boolean;
  states?: EntityStateUpdateManyWithoutEntityInput;
  defaultState?: EntityStateUpdateOneInput;
  instances?: EntityInstanceUpdateManyWithoutEntityInput;
}

export interface EntityUpsertWithoutFieldsInput {
  update: EntityUpdateWithoutFieldsDataInput;
  create: EntityCreateWithoutFieldsInput;
}

export interface EntityFieldUpsertNestedInput {
  update: EntityFieldUpdateDataInput;
  create: EntityFieldCreateInput;
}

export interface EntityInstanceFieldUpsertWithWhereUniqueNestedInput {
  where: EntityInstanceFieldWhereUniqueInput;
  update: EntityInstanceFieldUpdateDataInput;
  create: EntityInstanceFieldCreateInput;
}

export interface EntityInstanceFieldScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  value?: String;
  value_not?: String;
  value_in?: String[] | String;
  value_not_in?: String[] | String;
  value_lt?: String;
  value_lte?: String;
  value_gt?: String;
  value_gte?: String;
  value_contains?: String;
  value_not_contains?: String;
  value_starts_with?: String;
  value_not_starts_with?: String;
  value_ends_with?: String;
  value_not_ends_with?: String;
  AND?:
    | EntityInstanceFieldScalarWhereInput[]
    | EntityInstanceFieldScalarWhereInput;
  OR?:
    | EntityInstanceFieldScalarWhereInput[]
    | EntityInstanceFieldScalarWhereInput;
  NOT?:
    | EntityInstanceFieldScalarWhereInput[]
    | EntityInstanceFieldScalarWhereInput;
}

export interface EntityInstanceFieldUpdateManyWithWhereNestedInput {
  where: EntityInstanceFieldScalarWhereInput;
  data: EntityInstanceFieldUpdateManyDataInput;
}

export interface EntityInstanceFieldUpdateManyDataInput {
  value?: String;
}

export interface EntityInstanceStateUpdateManyWithoutInstanceInput {
  create?:
    | EntityInstanceStateCreateWithoutInstanceInput[]
    | EntityInstanceStateCreateWithoutInstanceInput;
  delete?:
    | EntityInstanceStateWhereUniqueInput[]
    | EntityInstanceStateWhereUniqueInput;
  connect?:
    | EntityInstanceStateWhereUniqueInput[]
    | EntityInstanceStateWhereUniqueInput;
  disconnect?:
    | EntityInstanceStateWhereUniqueInput[]
    | EntityInstanceStateWhereUniqueInput;
  update?:
    | EntityInstanceStateUpdateWithWhereUniqueWithoutInstanceInput[]
    | EntityInstanceStateUpdateWithWhereUniqueWithoutInstanceInput;
  upsert?:
    | EntityInstanceStateUpsertWithWhereUniqueWithoutInstanceInput[]
    | EntityInstanceStateUpsertWithWhereUniqueWithoutInstanceInput;
  deleteMany?:
    | EntityInstanceStateScalarWhereInput[]
    | EntityInstanceStateScalarWhereInput;
}

export interface EntityInstanceStateUpdateWithWhereUniqueWithoutInstanceInput {
  where: EntityInstanceStateWhereUniqueInput;
  data: EntityInstanceStateUpdateWithoutInstanceDataInput;
}

export interface EntityInstanceStateUpdateWithoutInstanceDataInput {
  state?: EntityStateUpdateOneRequiredInput;
  outgoingTransitions?: EntityInstanceStateTransitionUpdateManyWithoutFromInput;
  incomingTransitions?: EntityInstanceStateTransitionUpdateManyWithoutToInput;
  unlockedBy?: EntityInstanceStateTransitionUpdateOneWithoutUnlocksInput;
}

export interface EntityStateUpdateOneRequiredInput {
  create?: EntityStateCreateInput;
  update?: EntityStateUpdateDataInput;
  upsert?: EntityStateUpsertNestedInput;
  connect?: EntityStateWhereUniqueInput;
}

export interface EntityStateUpsertNestedInput {
  update: EntityStateUpdateDataInput;
  create: EntityStateCreateInput;
}

export interface EntityInstanceStateTransitionUpdateManyWithoutFromInput {
  create?:
    | EntityInstanceStateTransitionCreateWithoutFromInput[]
    | EntityInstanceStateTransitionCreateWithoutFromInput;
  delete?:
    | EntityInstanceStateTransitionWhereUniqueInput[]
    | EntityInstanceStateTransitionWhereUniqueInput;
  connect?:
    | EntityInstanceStateTransitionWhereUniqueInput[]
    | EntityInstanceStateTransitionWhereUniqueInput;
  disconnect?:
    | EntityInstanceStateTransitionWhereUniqueInput[]
    | EntityInstanceStateTransitionWhereUniqueInput;
  update?:
    | EntityInstanceStateTransitionUpdateWithWhereUniqueWithoutFromInput[]
    | EntityInstanceStateTransitionUpdateWithWhereUniqueWithoutFromInput;
  upsert?:
    | EntityInstanceStateTransitionUpsertWithWhereUniqueWithoutFromInput[]
    | EntityInstanceStateTransitionUpsertWithWhereUniqueWithoutFromInput;
  deleteMany?:
    | EntityInstanceStateTransitionScalarWhereInput[]
    | EntityInstanceStateTransitionScalarWhereInput;
}

export interface EntityInstanceStateTransitionUpdateWithWhereUniqueWithoutFromInput {
  where: EntityInstanceStateTransitionWhereUniqueInput;
  data: EntityInstanceStateTransitionUpdateWithoutFromDataInput;
}

export interface EntityInstanceStateTransitionUpdateWithoutFromDataInput {
  to?: EntityInstanceStateUpdateOneWithoutIncomingTransitionsInput;
  unlocks?: EntityInstanceStateUpdateManyWithoutUnlockedByInput;
}

export interface EntityInstanceStateUpdateOneWithoutIncomingTransitionsInput {
  create?: EntityInstanceStateCreateWithoutIncomingTransitionsInput;
  update?: EntityInstanceStateUpdateWithoutIncomingTransitionsDataInput;
  upsert?: EntityInstanceStateUpsertWithoutIncomingTransitionsInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: EntityInstanceStateWhereUniqueInput;
}

export interface EntityInstanceStateUpdateWithoutIncomingTransitionsDataInput {
  state?: EntityStateUpdateOneRequiredInput;
  outgoingTransitions?: EntityInstanceStateTransitionUpdateManyWithoutFromInput;
  unlockedBy?: EntityInstanceStateTransitionUpdateOneWithoutUnlocksInput;
  instance?: EntityInstanceUpdateOneRequiredWithoutStatesInput;
}

export interface EntityInstanceStateTransitionUpdateOneWithoutUnlocksInput {
  create?: EntityInstanceStateTransitionCreateWithoutUnlocksInput;
  update?: EntityInstanceStateTransitionUpdateWithoutUnlocksDataInput;
  upsert?: EntityInstanceStateTransitionUpsertWithoutUnlocksInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: EntityInstanceStateTransitionWhereUniqueInput;
}

export interface EntityInstanceStateTransitionUpdateWithoutUnlocksDataInput {
  from?: EntityInstanceStateUpdateOneRequiredWithoutOutgoingTransitionsInput;
  to?: EntityInstanceStateUpdateOneWithoutIncomingTransitionsInput;
}

export interface EntityInstanceStateUpdateOneRequiredWithoutOutgoingTransitionsInput {
  create?: EntityInstanceStateCreateWithoutOutgoingTransitionsInput;
  update?: EntityInstanceStateUpdateWithoutOutgoingTransitionsDataInput;
  upsert?: EntityInstanceStateUpsertWithoutOutgoingTransitionsInput;
  connect?: EntityInstanceStateWhereUniqueInput;
}

export interface EntityInstanceStateUpdateWithoutOutgoingTransitionsDataInput {
  state?: EntityStateUpdateOneRequiredInput;
  incomingTransitions?: EntityInstanceStateTransitionUpdateManyWithoutToInput;
  unlockedBy?: EntityInstanceStateTransitionUpdateOneWithoutUnlocksInput;
  instance?: EntityInstanceUpdateOneRequiredWithoutStatesInput;
}

export interface EntityInstanceStateTransitionUpdateManyWithoutToInput {
  create?:
    | EntityInstanceStateTransitionCreateWithoutToInput[]
    | EntityInstanceStateTransitionCreateWithoutToInput;
  delete?:
    | EntityInstanceStateTransitionWhereUniqueInput[]
    | EntityInstanceStateTransitionWhereUniqueInput;
  connect?:
    | EntityInstanceStateTransitionWhereUniqueInput[]
    | EntityInstanceStateTransitionWhereUniqueInput;
  disconnect?:
    | EntityInstanceStateTransitionWhereUniqueInput[]
    | EntityInstanceStateTransitionWhereUniqueInput;
  update?:
    | EntityInstanceStateTransitionUpdateWithWhereUniqueWithoutToInput[]
    | EntityInstanceStateTransitionUpdateWithWhereUniqueWithoutToInput;
  upsert?:
    | EntityInstanceStateTransitionUpsertWithWhereUniqueWithoutToInput[]
    | EntityInstanceStateTransitionUpsertWithWhereUniqueWithoutToInput;
  deleteMany?:
    | EntityInstanceStateTransitionScalarWhereInput[]
    | EntityInstanceStateTransitionScalarWhereInput;
}

export interface EntityInstanceStateTransitionUpdateWithWhereUniqueWithoutToInput {
  where: EntityInstanceStateTransitionWhereUniqueInput;
  data: EntityInstanceStateTransitionUpdateWithoutToDataInput;
}

export interface EntityInstanceStateTransitionUpdateWithoutToDataInput {
  from?: EntityInstanceStateUpdateOneRequiredWithoutOutgoingTransitionsInput;
  unlocks?: EntityInstanceStateUpdateManyWithoutUnlockedByInput;
}

export interface EntityInstanceStateUpdateManyWithoutUnlockedByInput {
  create?:
    | EntityInstanceStateCreateWithoutUnlockedByInput[]
    | EntityInstanceStateCreateWithoutUnlockedByInput;
  delete?:
    | EntityInstanceStateWhereUniqueInput[]
    | EntityInstanceStateWhereUniqueInput;
  connect?:
    | EntityInstanceStateWhereUniqueInput[]
    | EntityInstanceStateWhereUniqueInput;
  disconnect?:
    | EntityInstanceStateWhereUniqueInput[]
    | EntityInstanceStateWhereUniqueInput;
  update?:
    | EntityInstanceStateUpdateWithWhereUniqueWithoutUnlockedByInput[]
    | EntityInstanceStateUpdateWithWhereUniqueWithoutUnlockedByInput;
  upsert?:
    | EntityInstanceStateUpsertWithWhereUniqueWithoutUnlockedByInput[]
    | EntityInstanceStateUpsertWithWhereUniqueWithoutUnlockedByInput;
  deleteMany?:
    | EntityInstanceStateScalarWhereInput[]
    | EntityInstanceStateScalarWhereInput;
}

export interface EntityInstanceStateUpdateWithWhereUniqueWithoutUnlockedByInput {
  where: EntityInstanceStateWhereUniqueInput;
  data: EntityInstanceStateUpdateWithoutUnlockedByDataInput;
}

export interface EntityInstanceStateUpdateWithoutUnlockedByDataInput {
  state?: EntityStateUpdateOneRequiredInput;
  outgoingTransitions?: EntityInstanceStateTransitionUpdateManyWithoutFromInput;
  incomingTransitions?: EntityInstanceStateTransitionUpdateManyWithoutToInput;
  instance?: EntityInstanceUpdateOneRequiredWithoutStatesInput;
}

export interface EntityInstanceUpdateOneRequiredWithoutStatesInput {
  create?: EntityInstanceCreateWithoutStatesInput;
  update?: EntityInstanceUpdateWithoutStatesDataInput;
  upsert?: EntityInstanceUpsertWithoutStatesInput;
  connect?: EntityInstanceWhereUniqueInput;
}

export interface EntityInstanceUpdateWithoutStatesDataInput {
  name?: String;
  description?: String;
  game?: GameUpdateOneRequiredWithoutInstancesInput;
  entity?: EntityUpdateOneRequiredWithoutInstancesInput;
  fields?: EntityInstanceFieldUpdateManyInput;
}

export interface EntityInstanceUpsertWithoutStatesInput {
  update: EntityInstanceUpdateWithoutStatesDataInput;
  create: EntityInstanceCreateWithoutStatesInput;
}

export interface EntityInstanceStateUpsertWithWhereUniqueWithoutUnlockedByInput {
  where: EntityInstanceStateWhereUniqueInput;
  update: EntityInstanceStateUpdateWithoutUnlockedByDataInput;
  create: EntityInstanceStateCreateWithoutUnlockedByInput;
}

export interface EntityInstanceStateScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  AND?:
    | EntityInstanceStateScalarWhereInput[]
    | EntityInstanceStateScalarWhereInput;
  OR?:
    | EntityInstanceStateScalarWhereInput[]
    | EntityInstanceStateScalarWhereInput;
  NOT?:
    | EntityInstanceStateScalarWhereInput[]
    | EntityInstanceStateScalarWhereInput;
}

export interface EntityInstanceStateTransitionUpsertWithWhereUniqueWithoutToInput {
  where: EntityInstanceStateTransitionWhereUniqueInput;
  update: EntityInstanceStateTransitionUpdateWithoutToDataInput;
  create: EntityInstanceStateTransitionCreateWithoutToInput;
}

export interface EntityInstanceStateTransitionScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  AND?:
    | EntityInstanceStateTransitionScalarWhereInput[]
    | EntityInstanceStateTransitionScalarWhereInput;
  OR?:
    | EntityInstanceStateTransitionScalarWhereInput[]
    | EntityInstanceStateTransitionScalarWhereInput;
  NOT?:
    | EntityInstanceStateTransitionScalarWhereInput[]
    | EntityInstanceStateTransitionScalarWhereInput;
}

export interface EntityInstanceStateUpsertWithoutOutgoingTransitionsInput {
  update: EntityInstanceStateUpdateWithoutOutgoingTransitionsDataInput;
  create: EntityInstanceStateCreateWithoutOutgoingTransitionsInput;
}

export interface EntityInstanceStateTransitionUpsertWithoutUnlocksInput {
  update: EntityInstanceStateTransitionUpdateWithoutUnlocksDataInput;
  create: EntityInstanceStateTransitionCreateWithoutUnlocksInput;
}

export interface EntityInstanceStateUpsertWithoutIncomingTransitionsInput {
  update: EntityInstanceStateUpdateWithoutIncomingTransitionsDataInput;
  create: EntityInstanceStateCreateWithoutIncomingTransitionsInput;
}

export interface EntityInstanceStateTransitionUpsertWithWhereUniqueWithoutFromInput {
  where: EntityInstanceStateTransitionWhereUniqueInput;
  update: EntityInstanceStateTransitionUpdateWithoutFromDataInput;
  create: EntityInstanceStateTransitionCreateWithoutFromInput;
}

export interface EntityInstanceStateUpsertWithWhereUniqueWithoutInstanceInput {
  where: EntityInstanceStateWhereUniqueInput;
  update: EntityInstanceStateUpdateWithoutInstanceDataInput;
  create: EntityInstanceStateCreateWithoutInstanceInput;
}

export interface EntityInstanceUpsertWithWhereUniqueWithoutEntityInput {
  where: EntityInstanceWhereUniqueInput;
  update: EntityInstanceUpdateWithoutEntityDataInput;
  create: EntityInstanceCreateWithoutEntityInput;
}

export interface EntityInstanceScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  AND?: EntityInstanceScalarWhereInput[] | EntityInstanceScalarWhereInput;
  OR?: EntityInstanceScalarWhereInput[] | EntityInstanceScalarWhereInput;
  NOT?: EntityInstanceScalarWhereInput[] | EntityInstanceScalarWhereInput;
}

export interface EntityInstanceUpdateManyWithWhereNestedInput {
  where: EntityInstanceScalarWhereInput;
  data: EntityInstanceUpdateManyDataInput;
}

export interface EntityInstanceUpdateManyDataInput {
  name?: String;
  description?: String;
}

export interface EntityUpsertWithoutStatesInput {
  update: EntityUpdateWithoutStatesDataInput;
  create: EntityCreateWithoutStatesInput;
}

export interface EntityStateUpsertWithoutOutgoingTransitionsInput {
  update: EntityStateUpdateWithoutOutgoingTransitionsDataInput;
  create: EntityStateCreateWithoutOutgoingTransitionsInput;
}

export interface EntityStateTransitionUpsertWithWhereUniqueWithoutToInput {
  where: EntityStateTransitionWhereUniqueInput;
  update: EntityStateTransitionUpdateWithoutToDataInput;
  create: EntityStateTransitionCreateWithoutToInput;
}

export interface EntityStateTransitionScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  AND?:
    | EntityStateTransitionScalarWhereInput[]
    | EntityStateTransitionScalarWhereInput;
  OR?:
    | EntityStateTransitionScalarWhereInput[]
    | EntityStateTransitionScalarWhereInput;
  NOT?:
    | EntityStateTransitionScalarWhereInput[]
    | EntityStateTransitionScalarWhereInput;
}

export interface EntityUpsertNestedInput {
  update: EntityUpdateDataInput;
  create: EntityCreateInput;
}

export interface ActionRequirementPayloadEntityUpsertWithoutPayloadInput {
  update: ActionRequirementPayloadEntityUpdateWithoutPayloadDataInput;
  create: ActionRequirementPayloadEntityCreateWithoutPayloadInput;
}

export interface ActionRequirementPayloadInputValueUpdateManyWithoutPayloadInput {
  create?:
    | ActionRequirementPayloadInputValueCreateWithoutPayloadInput[]
    | ActionRequirementPayloadInputValueCreateWithoutPayloadInput;
  delete?:
    | ActionRequirementPayloadInputValueWhereUniqueInput[]
    | ActionRequirementPayloadInputValueWhereUniqueInput;
  connect?:
    | ActionRequirementPayloadInputValueWhereUniqueInput[]
    | ActionRequirementPayloadInputValueWhereUniqueInput;
  disconnect?:
    | ActionRequirementPayloadInputValueWhereUniqueInput[]
    | ActionRequirementPayloadInputValueWhereUniqueInput;
  update?:
    | ActionRequirementPayloadInputValueUpdateWithWhereUniqueWithoutPayloadInput[]
    | ActionRequirementPayloadInputValueUpdateWithWhereUniqueWithoutPayloadInput;
  upsert?:
    | ActionRequirementPayloadInputValueUpsertWithWhereUniqueWithoutPayloadInput[]
    | ActionRequirementPayloadInputValueUpsertWithWhereUniqueWithoutPayloadInput;
  deleteMany?:
    | ActionRequirementPayloadInputValueScalarWhereInput[]
    | ActionRequirementPayloadInputValueScalarWhereInput;
  updateMany?:
    | ActionRequirementPayloadInputValueUpdateManyWithWhereNestedInput[]
    | ActionRequirementPayloadInputValueUpdateManyWithWhereNestedInput;
}

export interface ActionRequirementPayloadInputValueUpdateWithWhereUniqueWithoutPayloadInput {
  where: ActionRequirementPayloadInputValueWhereUniqueInput;
  data: ActionRequirementPayloadInputValueUpdateWithoutPayloadDataInput;
}

export interface ActionRequirementPayloadInputValueUpdateWithoutPayloadDataInput {
  key?: String;
  eqField?: EntityFieldUpdateOneInput;
  neqField?: EntityFieldUpdateOneInput;
  eqValue?: String;
  neqValue?: String;
}

export interface EntityFieldUpdateOneInput {
  create?: EntityFieldCreateInput;
  update?: EntityFieldUpdateDataInput;
  upsert?: EntityFieldUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: EntityFieldWhereUniqueInput;
}

export interface ActionRequirementPayloadInputValueUpsertWithWhereUniqueWithoutPayloadInput {
  where: ActionRequirementPayloadInputValueWhereUniqueInput;
  update: ActionRequirementPayloadInputValueUpdateWithoutPayloadDataInput;
  create: ActionRequirementPayloadInputValueCreateWithoutPayloadInput;
}

export interface ActionRequirementPayloadInputValueScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  key?: String;
  key_not?: String;
  key_in?: String[] | String;
  key_not_in?: String[] | String;
  key_lt?: String;
  key_lte?: String;
  key_gt?: String;
  key_gte?: String;
  key_contains?: String;
  key_not_contains?: String;
  key_starts_with?: String;
  key_not_starts_with?: String;
  key_ends_with?: String;
  key_not_ends_with?: String;
  eqValue?: String;
  eqValue_not?: String;
  eqValue_in?: String[] | String;
  eqValue_not_in?: String[] | String;
  eqValue_lt?: String;
  eqValue_lte?: String;
  eqValue_gt?: String;
  eqValue_gte?: String;
  eqValue_contains?: String;
  eqValue_not_contains?: String;
  eqValue_starts_with?: String;
  eqValue_not_starts_with?: String;
  eqValue_ends_with?: String;
  eqValue_not_ends_with?: String;
  neqValue?: String;
  neqValue_not?: String;
  neqValue_in?: String[] | String;
  neqValue_not_in?: String[] | String;
  neqValue_lt?: String;
  neqValue_lte?: String;
  neqValue_gt?: String;
  neqValue_gte?: String;
  neqValue_contains?: String;
  neqValue_not_contains?: String;
  neqValue_starts_with?: String;
  neqValue_not_starts_with?: String;
  neqValue_ends_with?: String;
  neqValue_not_ends_with?: String;
  AND?:
    | ActionRequirementPayloadInputValueScalarWhereInput[]
    | ActionRequirementPayloadInputValueScalarWhereInput;
  OR?:
    | ActionRequirementPayloadInputValueScalarWhereInput[]
    | ActionRequirementPayloadInputValueScalarWhereInput;
  NOT?:
    | ActionRequirementPayloadInputValueScalarWhereInput[]
    | ActionRequirementPayloadInputValueScalarWhereInput;
}

export interface ActionRequirementPayloadInputValueUpdateManyWithWhereNestedInput {
  where: ActionRequirementPayloadInputValueScalarWhereInput;
  data: ActionRequirementPayloadInputValueUpdateManyDataInput;
}

export interface ActionRequirementPayloadInputValueUpdateManyDataInput {
  key?: String;
  eqValue?: String;
  neqValue?: String;
}

export interface ActionRequirementPayloadUpsertWithoutActionRequirementInput {
  update: ActionRequirementPayloadUpdateWithoutActionRequirementDataInput;
  create: ActionRequirementPayloadCreateWithoutActionRequirementInput;
}

export interface ActionRequirementUpsertWithWhereUniqueNestedInput {
  where: ActionRequirementWhereUniqueInput;
  update: ActionRequirementUpdateDataInput;
  create: ActionRequirementCreateInput;
}

export interface ActionRequirementScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  type?: ActionType;
  type_not?: ActionType;
  type_in?: ActionType[] | ActionType;
  type_not_in?: ActionType[] | ActionType;
  AND?: ActionRequirementScalarWhereInput[] | ActionRequirementScalarWhereInput;
  OR?: ActionRequirementScalarWhereInput[] | ActionRequirementScalarWhereInput;
  NOT?: ActionRequirementScalarWhereInput[] | ActionRequirementScalarWhereInput;
}

export interface ActionRequirementUpdateManyWithWhereNestedInput {
  where: ActionRequirementScalarWhereInput;
  data: ActionRequirementUpdateManyDataInput;
}

export interface ActionRequirementUpdateManyDataInput {
  type?: ActionType;
  hints?: ActionRequirementUpdatehintsInput;
}

export interface EntityStateUpdateOneWithoutIncomingTransitionsInput {
  create?: EntityStateCreateWithoutIncomingTransitionsInput;
  update?: EntityStateUpdateWithoutIncomingTransitionsDataInput;
  upsert?: EntityStateUpsertWithoutIncomingTransitionsInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: EntityStateWhereUniqueInput;
}

export interface EntityStateUpdateWithoutIncomingTransitionsDataInput {
  name?: String;
  description?: String;
  outgoingTransitions?: EntityStateTransitionUpdateManyWithoutFromInput;
  entity?: EntityUpdateOneRequiredWithoutStatesInput;
}

export interface EntityStateUpsertWithoutIncomingTransitionsInput {
  update: EntityStateUpdateWithoutIncomingTransitionsDataInput;
  create: EntityStateCreateWithoutIncomingTransitionsInput;
}

export interface EntityStateTransitionUpsertWithWhereUniqueWithoutFromInput {
  where: EntityStateTransitionWhereUniqueInput;
  update: EntityStateTransitionUpdateWithoutFromDataInput;
  create: EntityStateTransitionCreateWithoutFromInput;
}

export interface EntityStateUpsertWithWhereUniqueWithoutEntityInput {
  where: EntityStateWhereUniqueInput;
  update: EntityStateUpdateWithoutEntityDataInput;
  create: EntityStateCreateWithoutEntityInput;
}

export interface EntityStateScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  AND?: EntityStateScalarWhereInput[] | EntityStateScalarWhereInput;
  OR?: EntityStateScalarWhereInput[] | EntityStateScalarWhereInput;
  NOT?: EntityStateScalarWhereInput[] | EntityStateScalarWhereInput;
}

export interface EntityStateUpdateManyWithWhereNestedInput {
  where: EntityStateScalarWhereInput;
  data: EntityStateUpdateManyDataInput;
}

export interface EntityStateUpdateManyDataInput {
  name?: String;
  description?: String;
}

export interface EntityUpsertWithoutInstancesInput {
  update: EntityUpdateWithoutInstancesDataInput;
  create: EntityCreateWithoutInstancesInput;
}

export interface EntityInstanceUpsertWithWhereUniqueWithoutGameInput {
  where: EntityInstanceWhereUniqueInput;
  update: EntityInstanceUpdateWithoutGameDataInput;
  create: EntityInstanceCreateWithoutGameInput;
}

export interface GameUpsertWithoutPlaysInput {
  update: GameUpdateWithoutPlaysDataInput;
  create: GameCreateWithoutPlaysInput;
}

export interface ActionUpdateManyWithoutGamePlayInput {
  create?:
    | ActionCreateWithoutGamePlayInput[]
    | ActionCreateWithoutGamePlayInput;
  delete?: ActionWhereUniqueInput[] | ActionWhereUniqueInput;
  connect?: ActionWhereUniqueInput[] | ActionWhereUniqueInput;
  disconnect?: ActionWhereUniqueInput[] | ActionWhereUniqueInput;
  update?:
    | ActionUpdateWithWhereUniqueWithoutGamePlayInput[]
    | ActionUpdateWithWhereUniqueWithoutGamePlayInput;
  upsert?:
    | ActionUpsertWithWhereUniqueWithoutGamePlayInput[]
    | ActionUpsertWithWhereUniqueWithoutGamePlayInput;
  deleteMany?: ActionScalarWhereInput[] | ActionScalarWhereInput;
  updateMany?:
    | ActionUpdateManyWithWhereNestedInput[]
    | ActionUpdateManyWithWhereNestedInput;
}

export interface ActionUpdateWithWhereUniqueWithoutGamePlayInput {
  where: ActionWhereUniqueInput;
  data: ActionUpdateWithoutGamePlayDataInput;
}

export interface ActionUpdateWithoutGamePlayDataInput {
  type?: ActionType;
  payload?: ActionPayloadUpdateOneRequiredWithoutActionInput;
}

export interface ActionUpsertWithWhereUniqueWithoutGamePlayInput {
  where: ActionWhereUniqueInput;
  update: ActionUpdateWithoutGamePlayDataInput;
  create: ActionCreateWithoutGamePlayInput;
}

export interface ActionScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  type?: ActionType;
  type_not?: ActionType;
  type_in?: ActionType[] | ActionType;
  type_not_in?: ActionType[] | ActionType;
  AND?: ActionScalarWhereInput[] | ActionScalarWhereInput;
  OR?: ActionScalarWhereInput[] | ActionScalarWhereInput;
  NOT?: ActionScalarWhereInput[] | ActionScalarWhereInput;
}

export interface ActionUpdateManyWithWhereNestedInput {
  where: ActionScalarWhereInput;
  data: ActionUpdateManyDataInput;
}

export interface ActionUpdateManyDataInput {
  type?: ActionType;
}

export interface GamePlayUpsertWithWhereUniqueWithoutPlayerInput {
  where: GamePlayWhereUniqueInput;
  update: GamePlayUpdateWithoutPlayerDataInput;
  create: GamePlayCreateWithoutPlayerInput;
}

export interface GamePlayScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  AND?: GamePlayScalarWhereInput[] | GamePlayScalarWhereInput;
  OR?: GamePlayScalarWhereInput[] | GamePlayScalarWhereInput;
  NOT?: GamePlayScalarWhereInput[] | GamePlayScalarWhereInput;
}

export interface UserUpsertWithoutGamesInput {
  update: UserUpdateWithoutGamesDataInput;
  create: UserCreateWithoutGamesInput;
}

export interface GamePlayUpdateManyWithoutGameInput {
  create?: GamePlayCreateWithoutGameInput[] | GamePlayCreateWithoutGameInput;
  delete?: GamePlayWhereUniqueInput[] | GamePlayWhereUniqueInput;
  connect?: GamePlayWhereUniqueInput[] | GamePlayWhereUniqueInput;
  disconnect?: GamePlayWhereUniqueInput[] | GamePlayWhereUniqueInput;
  update?:
    | GamePlayUpdateWithWhereUniqueWithoutGameInput[]
    | GamePlayUpdateWithWhereUniqueWithoutGameInput;
  upsert?:
    | GamePlayUpsertWithWhereUniqueWithoutGameInput[]
    | GamePlayUpsertWithWhereUniqueWithoutGameInput;
  deleteMany?: GamePlayScalarWhereInput[] | GamePlayScalarWhereInput;
}

export interface GamePlayUpdateWithWhereUniqueWithoutGameInput {
  where: GamePlayWhereUniqueInput;
  data: GamePlayUpdateWithoutGameDataInput;
}

export interface GamePlayUpdateWithoutGameDataInput {
  player?: UserUpdateOneWithoutPlaysInput;
  actions?: ActionUpdateManyWithoutGamePlayInput;
}

export interface UserUpdateOneWithoutPlaysInput {
  create?: UserCreateWithoutPlaysInput;
  update?: UserUpdateWithoutPlaysDataInput;
  upsert?: UserUpsertWithoutPlaysInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: UserWhereUniqueInput;
}

export interface UserUpdateWithoutPlaysDataInput {
  name?: String;
  slug?: String;
  games?: GameUpdateManyWithoutCreatorInput;
}

export interface GameUpdateManyWithoutCreatorInput {
  create?: GameCreateWithoutCreatorInput[] | GameCreateWithoutCreatorInput;
  delete?: GameWhereUniqueInput[] | GameWhereUniqueInput;
  connect?: GameWhereUniqueInput[] | GameWhereUniqueInput;
  disconnect?: GameWhereUniqueInput[] | GameWhereUniqueInput;
  update?:
    | GameUpdateWithWhereUniqueWithoutCreatorInput[]
    | GameUpdateWithWhereUniqueWithoutCreatorInput;
  upsert?:
    | GameUpsertWithWhereUniqueWithoutCreatorInput[]
    | GameUpsertWithWhereUniqueWithoutCreatorInput;
  deleteMany?: GameScalarWhereInput[] | GameScalarWhereInput;
  updateMany?:
    | GameUpdateManyWithWhereNestedInput[]
    | GameUpdateManyWithWhereNestedInput;
}

export interface GameUpdateWithWhereUniqueWithoutCreatorInput {
  where: GameWhereUniqueInput;
  data: GameUpdateWithoutCreatorDataInput;
}

export interface GameUpdateWithoutCreatorDataInput {
  name?: String;
  slug?: String;
  description?: String;
  instances?: EntityInstanceUpdateManyWithoutGameInput;
  plays?: GamePlayUpdateManyWithoutGameInput;
}

export interface GameUpsertWithWhereUniqueWithoutCreatorInput {
  where: GameWhereUniqueInput;
  update: GameUpdateWithoutCreatorDataInput;
  create: GameCreateWithoutCreatorInput;
}

export interface GameScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  slug?: String;
  slug_not?: String;
  slug_in?: String[] | String;
  slug_not_in?: String[] | String;
  slug_lt?: String;
  slug_lte?: String;
  slug_gt?: String;
  slug_gte?: String;
  slug_contains?: String;
  slug_not_contains?: String;
  slug_starts_with?: String;
  slug_not_starts_with?: String;
  slug_ends_with?: String;
  slug_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  AND?: GameScalarWhereInput[] | GameScalarWhereInput;
  OR?: GameScalarWhereInput[] | GameScalarWhereInput;
  NOT?: GameScalarWhereInput[] | GameScalarWhereInput;
}

export interface GameUpdateManyWithWhereNestedInput {
  where: GameScalarWhereInput;
  data: GameUpdateManyDataInput;
}

export interface GameUpdateManyDataInput {
  name?: String;
  slug?: String;
  description?: String;
}

export interface UserUpsertWithoutPlaysInput {
  update: UserUpdateWithoutPlaysDataInput;
  create: UserCreateWithoutPlaysInput;
}

export interface GamePlayUpsertWithWhereUniqueWithoutGameInput {
  where: GamePlayWhereUniqueInput;
  update: GamePlayUpdateWithoutGameDataInput;
  create: GamePlayCreateWithoutGameInput;
}

export interface GameUpsertWithoutInstancesInput {
  update: GameUpdateWithoutInstancesDataInput;
  create: GameCreateWithoutInstancesInput;
}

export interface EntityInstanceUpsertNestedInput {
  update: EntityInstanceUpdateDataInput;
  create: EntityInstanceCreateInput;
}

export interface ActionPayloadInputValueUpdateManyInput {
  create?:
    | ActionPayloadInputValueCreateInput[]
    | ActionPayloadInputValueCreateInput;
  update?:
    | ActionPayloadInputValueUpdateWithWhereUniqueNestedInput[]
    | ActionPayloadInputValueUpdateWithWhereUniqueNestedInput;
  upsert?:
    | ActionPayloadInputValueUpsertWithWhereUniqueNestedInput[]
    | ActionPayloadInputValueUpsertWithWhereUniqueNestedInput;
  delete?:
    | ActionPayloadInputValueWhereUniqueInput[]
    | ActionPayloadInputValueWhereUniqueInput;
  connect?:
    | ActionPayloadInputValueWhereUniqueInput[]
    | ActionPayloadInputValueWhereUniqueInput;
  disconnect?:
    | ActionPayloadInputValueWhereUniqueInput[]
    | ActionPayloadInputValueWhereUniqueInput;
  deleteMany?:
    | ActionPayloadInputValueScalarWhereInput[]
    | ActionPayloadInputValueScalarWhereInput;
  updateMany?:
    | ActionPayloadInputValueUpdateManyWithWhereNestedInput[]
    | ActionPayloadInputValueUpdateManyWithWhereNestedInput;
}

export interface ActionPayloadInputValueUpdateWithWhereUniqueNestedInput {
  where: ActionPayloadInputValueWhereUniqueInput;
  data: ActionPayloadInputValueUpdateDataInput;
}

export interface ActionPayloadInputValueUpdateDataInput {
  key?: String;
  value?: String;
}

export interface ActionPayloadInputValueUpsertWithWhereUniqueNestedInput {
  where: ActionPayloadInputValueWhereUniqueInput;
  update: ActionPayloadInputValueUpdateDataInput;
  create: ActionPayloadInputValueCreateInput;
}

export interface ActionPayloadInputValueScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  key?: String;
  key_not?: String;
  key_in?: String[] | String;
  key_not_in?: String[] | String;
  key_lt?: String;
  key_lte?: String;
  key_gt?: String;
  key_gte?: String;
  key_contains?: String;
  key_not_contains?: String;
  key_starts_with?: String;
  key_not_starts_with?: String;
  key_ends_with?: String;
  key_not_ends_with?: String;
  value?: String;
  value_not?: String;
  value_in?: String[] | String;
  value_not_in?: String[] | String;
  value_lt?: String;
  value_lte?: String;
  value_gt?: String;
  value_gte?: String;
  value_contains?: String;
  value_not_contains?: String;
  value_starts_with?: String;
  value_not_starts_with?: String;
  value_ends_with?: String;
  value_not_ends_with?: String;
  AND?:
    | ActionPayloadInputValueScalarWhereInput[]
    | ActionPayloadInputValueScalarWhereInput;
  OR?:
    | ActionPayloadInputValueScalarWhereInput[]
    | ActionPayloadInputValueScalarWhereInput;
  NOT?:
    | ActionPayloadInputValueScalarWhereInput[]
    | ActionPayloadInputValueScalarWhereInput;
}

export interface ActionPayloadInputValueUpdateManyWithWhereNestedInput {
  where: ActionPayloadInputValueScalarWhereInput;
  data: ActionPayloadInputValueUpdateManyDataInput;
}

export interface ActionPayloadInputValueUpdateManyDataInput {
  key?: String;
  value?: String;
}

export interface ActionPayloadUpsertWithoutActionInput {
  update: ActionPayloadUpdateWithoutActionDataInput;
  create: ActionPayloadCreateWithoutActionInput;
}

export interface GamePlayUpdateOneRequiredWithoutActionsInput {
  create?: GamePlayCreateWithoutActionsInput;
  update?: GamePlayUpdateWithoutActionsDataInput;
  upsert?: GamePlayUpsertWithoutActionsInput;
  connect?: GamePlayWhereUniqueInput;
}

export interface GamePlayUpdateWithoutActionsDataInput {
  game?: GameUpdateOneRequiredWithoutPlaysInput;
  player?: UserUpdateOneWithoutPlaysInput;
}

export interface GamePlayUpsertWithoutActionsInput {
  update: GamePlayUpdateWithoutActionsDataInput;
  create: GamePlayCreateWithoutActionsInput;
}

export interface ActionUpdateManyMutationInput {
  type?: ActionType;
}

export interface ActionPayloadCreateInput {
  instance?: EntityInstanceCreateOneInput;
  state?: EntityStateCreateOneInput;
  item?: EntityInstanceCreateOneInput;
  inputValues?: ActionPayloadInputValueCreateManyInput;
  action?: ActionCreateOneWithoutPayloadInput;
}

export interface ActionCreateOneWithoutPayloadInput {
  create?: ActionCreateWithoutPayloadInput;
  connect?: ActionWhereUniqueInput;
}

export interface ActionCreateWithoutPayloadInput {
  type: ActionType;
  gamePlay: GamePlayCreateOneWithoutActionsInput;
}

export interface ActionPayloadUpdateInput {
  instance?: EntityInstanceUpdateOneInput;
  state?: EntityStateUpdateOneInput;
  item?: EntityInstanceUpdateOneInput;
  inputValues?: ActionPayloadInputValueUpdateManyInput;
  action?: ActionUpdateOneWithoutPayloadInput;
}

export interface ActionUpdateOneWithoutPayloadInput {
  create?: ActionCreateWithoutPayloadInput;
  update?: ActionUpdateWithoutPayloadDataInput;
  upsert?: ActionUpsertWithoutPayloadInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: ActionWhereUniqueInput;
}

export interface ActionUpdateWithoutPayloadDataInput {
  type?: ActionType;
  gamePlay?: GamePlayUpdateOneRequiredWithoutActionsInput;
}

export interface ActionUpsertWithoutPayloadInput {
  update: ActionUpdateWithoutPayloadDataInput;
  create: ActionCreateWithoutPayloadInput;
}

export interface ActionPayloadInputValueUpdateInput {
  key?: String;
  value?: String;
}

export interface ActionPayloadInputValueUpdateManyMutationInput {
  key?: String;
  value?: String;
}

export interface ActionRequirementUpdateInput {
  type?: ActionType;
  hints?: ActionRequirementUpdatehintsInput;
  payload?: ActionRequirementPayloadUpdateOneRequiredWithoutActionRequirementInput;
}

export interface ActionRequirementUpdateManyMutationInput {
  type?: ActionType;
  hints?: ActionRequirementUpdatehintsInput;
}

export interface ActionRequirementPayloadCreateInput {
  requiredEntity?: ActionRequirementPayloadEntityCreateOneWithoutPayloadInput;
  requiredValues?: ActionRequirementPayloadInputValueCreateManyWithoutPayloadInput;
  actionRequirement: ActionRequirementCreateOneWithoutPayloadInput;
}

export interface ActionRequirementCreateOneWithoutPayloadInput {
  create?: ActionRequirementCreateWithoutPayloadInput;
  connect?: ActionRequirementWhereUniqueInput;
}

export interface ActionRequirementCreateWithoutPayloadInput {
  type?: ActionType;
  hints?: ActionRequirementCreatehintsInput;
}

export interface ActionRequirementPayloadUpdateInput {
  requiredEntity?: ActionRequirementPayloadEntityUpdateOneWithoutPayloadInput;
  requiredValues?: ActionRequirementPayloadInputValueUpdateManyWithoutPayloadInput;
  actionRequirement?: ActionRequirementUpdateOneRequiredWithoutPayloadInput;
}

export interface ActionRequirementUpdateOneRequiredWithoutPayloadInput {
  create?: ActionRequirementCreateWithoutPayloadInput;
  update?: ActionRequirementUpdateWithoutPayloadDataInput;
  upsert?: ActionRequirementUpsertWithoutPayloadInput;
  connect?: ActionRequirementWhereUniqueInput;
}

export interface ActionRequirementUpdateWithoutPayloadDataInput {
  type?: ActionType;
  hints?: ActionRequirementUpdatehintsInput;
}

export interface ActionRequirementUpsertWithoutPayloadInput {
  update: ActionRequirementUpdateWithoutPayloadDataInput;
  create: ActionRequirementCreateWithoutPayloadInput;
}

export interface ActionRequirementPayloadEntityCreateInput {
  entity: EntityCreateOneInput;
  state: EntityStateCreateOneInput;
  payload: ActionRequirementPayloadCreateOneWithoutRequiredEntityInput;
}

export interface ActionRequirementPayloadCreateOneWithoutRequiredEntityInput {
  create?: ActionRequirementPayloadCreateWithoutRequiredEntityInput;
  connect?: ActionRequirementPayloadWhereUniqueInput;
}

export interface ActionRequirementPayloadCreateWithoutRequiredEntityInput {
  requiredValues?: ActionRequirementPayloadInputValueCreateManyWithoutPayloadInput;
  actionRequirement: ActionRequirementCreateOneWithoutPayloadInput;
}

export interface ActionRequirementPayloadEntityUpdateInput {
  entity?: EntityUpdateOneRequiredInput;
  state?: EntityStateUpdateOneRequiredInput;
  payload?: ActionRequirementPayloadUpdateOneRequiredWithoutRequiredEntityInput;
}

export interface ActionRequirementPayloadUpdateOneRequiredWithoutRequiredEntityInput {
  create?: ActionRequirementPayloadCreateWithoutRequiredEntityInput;
  update?: ActionRequirementPayloadUpdateWithoutRequiredEntityDataInput;
  upsert?: ActionRequirementPayloadUpsertWithoutRequiredEntityInput;
  connect?: ActionRequirementPayloadWhereUniqueInput;
}

export interface ActionRequirementPayloadUpdateWithoutRequiredEntityDataInput {
  requiredValues?: ActionRequirementPayloadInputValueUpdateManyWithoutPayloadInput;
  actionRequirement?: ActionRequirementUpdateOneRequiredWithoutPayloadInput;
}

export interface ActionRequirementPayloadUpsertWithoutRequiredEntityInput {
  update: ActionRequirementPayloadUpdateWithoutRequiredEntityDataInput;
  create: ActionRequirementPayloadCreateWithoutRequiredEntityInput;
}

export interface ActionRequirementPayloadInputValueCreateInput {
  key: String;
  eqField?: EntityFieldCreateOneInput;
  neqField?: EntityFieldCreateOneInput;
  eqValue?: String;
  neqValue?: String;
  payload: ActionRequirementPayloadCreateOneWithoutRequiredValuesInput;
}

export interface ActionRequirementPayloadCreateOneWithoutRequiredValuesInput {
  create?: ActionRequirementPayloadCreateWithoutRequiredValuesInput;
  connect?: ActionRequirementPayloadWhereUniqueInput;
}

export interface ActionRequirementPayloadCreateWithoutRequiredValuesInput {
  requiredEntity?: ActionRequirementPayloadEntityCreateOneWithoutPayloadInput;
  actionRequirement: ActionRequirementCreateOneWithoutPayloadInput;
}

export interface ActionRequirementPayloadInputValueUpdateInput {
  key?: String;
  eqField?: EntityFieldUpdateOneInput;
  neqField?: EntityFieldUpdateOneInput;
  eqValue?: String;
  neqValue?: String;
  payload?: ActionRequirementPayloadUpdateOneRequiredWithoutRequiredValuesInput;
}

export interface ActionRequirementPayloadUpdateOneRequiredWithoutRequiredValuesInput {
  create?: ActionRequirementPayloadCreateWithoutRequiredValuesInput;
  update?: ActionRequirementPayloadUpdateWithoutRequiredValuesDataInput;
  upsert?: ActionRequirementPayloadUpsertWithoutRequiredValuesInput;
  connect?: ActionRequirementPayloadWhereUniqueInput;
}

export interface ActionRequirementPayloadUpdateWithoutRequiredValuesDataInput {
  requiredEntity?: ActionRequirementPayloadEntityUpdateOneWithoutPayloadInput;
  actionRequirement?: ActionRequirementUpdateOneRequiredWithoutPayloadInput;
}

export interface ActionRequirementPayloadUpsertWithoutRequiredValuesInput {
  update: ActionRequirementPayloadUpdateWithoutRequiredValuesDataInput;
  create: ActionRequirementPayloadCreateWithoutRequiredValuesInput;
}

export interface ActionRequirementPayloadInputValueUpdateManyMutationInput {
  key?: String;
  eqValue?: String;
  neqValue?: String;
}

export interface EntityUpdateInput {
  name?: String;
  description?: String;
  isTrigger?: Boolean;
  isItem?: Boolean;
  isObject?: Boolean;
  fields?: EntityFieldUpdateManyWithoutEntityInput;
  states?: EntityStateUpdateManyWithoutEntityInput;
  defaultState?: EntityStateUpdateOneInput;
  instances?: EntityInstanceUpdateManyWithoutEntityInput;
}

export interface EntityUpdateManyMutationInput {
  name?: String;
  description?: String;
  isTrigger?: Boolean;
  isItem?: Boolean;
  isObject?: Boolean;
}

export interface EntityFieldUpdateInput {
  info?: String;
  label?: String;
  type?: FieldType;
  isMulti?: Boolean;
  isSecret?: Boolean;
  entity?: EntityUpdateOneRequiredWithoutFieldsInput;
}

export interface EntityFieldUpdateManyMutationInput {
  info?: String;
  label?: String;
  type?: FieldType;
  isMulti?: Boolean;
  isSecret?: Boolean;
}

export interface EntityInstanceUpdateInput {
  name?: String;
  description?: String;
  game?: GameUpdateOneRequiredWithoutInstancesInput;
  entity?: EntityUpdateOneRequiredWithoutInstancesInput;
  fields?: EntityInstanceFieldUpdateManyInput;
  states?: EntityInstanceStateUpdateManyWithoutInstanceInput;
}

export interface EntityInstanceUpdateManyMutationInput {
  name?: String;
  description?: String;
}

export interface EntityInstanceFieldUpdateInput {
  field?: EntityFieldUpdateOneRequiredInput;
  value?: String;
}

export interface EntityInstanceFieldUpdateManyMutationInput {
  value?: String;
}

export interface EntityInstanceStateCreateInput {
  state: EntityStateCreateOneInput;
  outgoingTransitions?: EntityInstanceStateTransitionCreateManyWithoutFromInput;
  incomingTransitions?: EntityInstanceStateTransitionCreateManyWithoutToInput;
  unlockedBy?: EntityInstanceStateTransitionCreateOneWithoutUnlocksInput;
  instance: EntityInstanceCreateOneWithoutStatesInput;
}

export interface EntityInstanceStateUpdateInput {
  state?: EntityStateUpdateOneRequiredInput;
  outgoingTransitions?: EntityInstanceStateTransitionUpdateManyWithoutFromInput;
  incomingTransitions?: EntityInstanceStateTransitionUpdateManyWithoutToInput;
  unlockedBy?: EntityInstanceStateTransitionUpdateOneWithoutUnlocksInput;
  instance?: EntityInstanceUpdateOneRequiredWithoutStatesInput;
}

export interface EntityInstanceStateTransitionCreateInput {
  from: EntityInstanceStateCreateOneWithoutOutgoingTransitionsInput;
  to?: EntityInstanceStateCreateOneWithoutIncomingTransitionsInput;
  unlocks?: EntityInstanceStateCreateManyWithoutUnlockedByInput;
}

export interface EntityInstanceStateTransitionUpdateInput {
  from?: EntityInstanceStateUpdateOneRequiredWithoutOutgoingTransitionsInput;
  to?: EntityInstanceStateUpdateOneWithoutIncomingTransitionsInput;
  unlocks?: EntityInstanceStateUpdateManyWithoutUnlockedByInput;
}

export interface EntityStateUpdateInput {
  name?: String;
  description?: String;
  outgoingTransitions?: EntityStateTransitionUpdateManyWithoutFromInput;
  incomingTransitions?: EntityStateTransitionUpdateManyWithoutToInput;
  entity?: EntityUpdateOneRequiredWithoutStatesInput;
}

export interface EntityStateUpdateManyMutationInput {
  name?: String;
  description?: String;
}

export interface EntityStateTransitionCreateInput {
  requiredActions?: ActionRequirementCreateManyInput;
  from: EntityStateCreateOneWithoutOutgoingTransitionsInput;
  to?: EntityStateCreateOneWithoutIncomingTransitionsInput;
}

export interface EntityStateTransitionUpdateInput {
  requiredActions?: ActionRequirementUpdateManyInput;
  from?: EntityStateUpdateOneRequiredWithoutOutgoingTransitionsInput;
  to?: EntityStateUpdateOneWithoutIncomingTransitionsInput;
}

export interface GameCreateInput {
  name: String;
  slug: String;
  description?: String;
  creator?: UserCreateOneWithoutGamesInput;
  instances?: EntityInstanceCreateManyWithoutGameInput;
  plays?: GamePlayCreateManyWithoutGameInput;
}

export interface GameUpdateInput {
  name?: String;
  slug?: String;
  description?: String;
  creator?: UserUpdateOneWithoutGamesInput;
  instances?: EntityInstanceUpdateManyWithoutGameInput;
  plays?: GamePlayUpdateManyWithoutGameInput;
}

export interface GameUpdateManyMutationInput {
  name?: String;
  slug?: String;
  description?: String;
}

export interface GamePlayCreateInput {
  game: GameCreateOneWithoutPlaysInput;
  player?: UserCreateOneWithoutPlaysInput;
  actions?: ActionCreateManyWithoutGamePlayInput;
}

export interface GamePlayUpdateInput {
  game?: GameUpdateOneRequiredWithoutPlaysInput;
  player?: UserUpdateOneWithoutPlaysInput;
  actions?: ActionUpdateManyWithoutGamePlayInput;
}

export interface UserCreateInput {
  name: String;
  slug: String;
  games?: GameCreateManyWithoutCreatorInput;
  plays?: GamePlayCreateManyWithoutPlayerInput;
}

export interface UserUpdateInput {
  name?: String;
  slug?: String;
  games?: GameUpdateManyWithoutCreatorInput;
  plays?: GamePlayUpdateManyWithoutPlayerInput;
}

export interface UserUpdateManyMutationInput {
  name?: String;
  slug?: String;
}

export interface ActionSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ActionWhereInput;
  AND?: ActionSubscriptionWhereInput[] | ActionSubscriptionWhereInput;
  OR?: ActionSubscriptionWhereInput[] | ActionSubscriptionWhereInput;
  NOT?: ActionSubscriptionWhereInput[] | ActionSubscriptionWhereInput;
}

export interface ActionPayloadSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ActionPayloadWhereInput;
  AND?:
    | ActionPayloadSubscriptionWhereInput[]
    | ActionPayloadSubscriptionWhereInput;
  OR?:
    | ActionPayloadSubscriptionWhereInput[]
    | ActionPayloadSubscriptionWhereInput;
  NOT?:
    | ActionPayloadSubscriptionWhereInput[]
    | ActionPayloadSubscriptionWhereInput;
}

export interface ActionPayloadInputValueSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ActionPayloadInputValueWhereInput;
  AND?:
    | ActionPayloadInputValueSubscriptionWhereInput[]
    | ActionPayloadInputValueSubscriptionWhereInput;
  OR?:
    | ActionPayloadInputValueSubscriptionWhereInput[]
    | ActionPayloadInputValueSubscriptionWhereInput;
  NOT?:
    | ActionPayloadInputValueSubscriptionWhereInput[]
    | ActionPayloadInputValueSubscriptionWhereInput;
}

export interface ActionRequirementSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ActionRequirementWhereInput;
  AND?:
    | ActionRequirementSubscriptionWhereInput[]
    | ActionRequirementSubscriptionWhereInput;
  OR?:
    | ActionRequirementSubscriptionWhereInput[]
    | ActionRequirementSubscriptionWhereInput;
  NOT?:
    | ActionRequirementSubscriptionWhereInput[]
    | ActionRequirementSubscriptionWhereInput;
}

export interface ActionRequirementPayloadSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ActionRequirementPayloadWhereInput;
  AND?:
    | ActionRequirementPayloadSubscriptionWhereInput[]
    | ActionRequirementPayloadSubscriptionWhereInput;
  OR?:
    | ActionRequirementPayloadSubscriptionWhereInput[]
    | ActionRequirementPayloadSubscriptionWhereInput;
  NOT?:
    | ActionRequirementPayloadSubscriptionWhereInput[]
    | ActionRequirementPayloadSubscriptionWhereInput;
}

export interface ActionRequirementPayloadEntitySubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ActionRequirementPayloadEntityWhereInput;
  AND?:
    | ActionRequirementPayloadEntitySubscriptionWhereInput[]
    | ActionRequirementPayloadEntitySubscriptionWhereInput;
  OR?:
    | ActionRequirementPayloadEntitySubscriptionWhereInput[]
    | ActionRequirementPayloadEntitySubscriptionWhereInput;
  NOT?:
    | ActionRequirementPayloadEntitySubscriptionWhereInput[]
    | ActionRequirementPayloadEntitySubscriptionWhereInput;
}

export interface ActionRequirementPayloadInputValueSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ActionRequirementPayloadInputValueWhereInput;
  AND?:
    | ActionRequirementPayloadInputValueSubscriptionWhereInput[]
    | ActionRequirementPayloadInputValueSubscriptionWhereInput;
  OR?:
    | ActionRequirementPayloadInputValueSubscriptionWhereInput[]
    | ActionRequirementPayloadInputValueSubscriptionWhereInput;
  NOT?:
    | ActionRequirementPayloadInputValueSubscriptionWhereInput[]
    | ActionRequirementPayloadInputValueSubscriptionWhereInput;
}

export interface EntitySubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: EntityWhereInput;
  AND?: EntitySubscriptionWhereInput[] | EntitySubscriptionWhereInput;
  OR?: EntitySubscriptionWhereInput[] | EntitySubscriptionWhereInput;
  NOT?: EntitySubscriptionWhereInput[] | EntitySubscriptionWhereInput;
}

export interface EntityFieldSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: EntityFieldWhereInput;
  AND?: EntityFieldSubscriptionWhereInput[] | EntityFieldSubscriptionWhereInput;
  OR?: EntityFieldSubscriptionWhereInput[] | EntityFieldSubscriptionWhereInput;
  NOT?: EntityFieldSubscriptionWhereInput[] | EntityFieldSubscriptionWhereInput;
}

export interface EntityInstanceSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: EntityInstanceWhereInput;
  AND?:
    | EntityInstanceSubscriptionWhereInput[]
    | EntityInstanceSubscriptionWhereInput;
  OR?:
    | EntityInstanceSubscriptionWhereInput[]
    | EntityInstanceSubscriptionWhereInput;
  NOT?:
    | EntityInstanceSubscriptionWhereInput[]
    | EntityInstanceSubscriptionWhereInput;
}

export interface EntityInstanceFieldSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: EntityInstanceFieldWhereInput;
  AND?:
    | EntityInstanceFieldSubscriptionWhereInput[]
    | EntityInstanceFieldSubscriptionWhereInput;
  OR?:
    | EntityInstanceFieldSubscriptionWhereInput[]
    | EntityInstanceFieldSubscriptionWhereInput;
  NOT?:
    | EntityInstanceFieldSubscriptionWhereInput[]
    | EntityInstanceFieldSubscriptionWhereInput;
}

export interface EntityInstanceStateSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: EntityInstanceStateWhereInput;
  AND?:
    | EntityInstanceStateSubscriptionWhereInput[]
    | EntityInstanceStateSubscriptionWhereInput;
  OR?:
    | EntityInstanceStateSubscriptionWhereInput[]
    | EntityInstanceStateSubscriptionWhereInput;
  NOT?:
    | EntityInstanceStateSubscriptionWhereInput[]
    | EntityInstanceStateSubscriptionWhereInput;
}

export interface EntityInstanceStateTransitionSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: EntityInstanceStateTransitionWhereInput;
  AND?:
    | EntityInstanceStateTransitionSubscriptionWhereInput[]
    | EntityInstanceStateTransitionSubscriptionWhereInput;
  OR?:
    | EntityInstanceStateTransitionSubscriptionWhereInput[]
    | EntityInstanceStateTransitionSubscriptionWhereInput;
  NOT?:
    | EntityInstanceStateTransitionSubscriptionWhereInput[]
    | EntityInstanceStateTransitionSubscriptionWhereInput;
}

export interface EntityStateSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: EntityStateWhereInput;
  AND?: EntityStateSubscriptionWhereInput[] | EntityStateSubscriptionWhereInput;
  OR?: EntityStateSubscriptionWhereInput[] | EntityStateSubscriptionWhereInput;
  NOT?: EntityStateSubscriptionWhereInput[] | EntityStateSubscriptionWhereInput;
}

export interface EntityStateTransitionSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: EntityStateTransitionWhereInput;
  AND?:
    | EntityStateTransitionSubscriptionWhereInput[]
    | EntityStateTransitionSubscriptionWhereInput;
  OR?:
    | EntityStateTransitionSubscriptionWhereInput[]
    | EntityStateTransitionSubscriptionWhereInput;
  NOT?:
    | EntityStateTransitionSubscriptionWhereInput[]
    | EntityStateTransitionSubscriptionWhereInput;
}

export interface GameSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: GameWhereInput;
  AND?: GameSubscriptionWhereInput[] | GameSubscriptionWhereInput;
  OR?: GameSubscriptionWhereInput[] | GameSubscriptionWhereInput;
  NOT?: GameSubscriptionWhereInput[] | GameSubscriptionWhereInput;
}

export interface GamePlaySubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: GamePlayWhereInput;
  AND?: GamePlaySubscriptionWhereInput[] | GamePlaySubscriptionWhereInput;
  OR?: GamePlaySubscriptionWhereInput[] | GamePlaySubscriptionWhereInput;
  NOT?: GamePlaySubscriptionWhereInput[] | GamePlaySubscriptionWhereInput;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: UserWhereInput;
  AND?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  OR?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  NOT?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
}

export interface NodeNode {
  id: ID_Output;
}

export interface Action {
  id: ID_Output;
  createdAt: DateTimeOutput;
  type: ActionType;
}

export interface ActionPromise extends Promise<Action>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  type: () => Promise<ActionType>;
  payload: <T = ActionPayloadPromise>() => T;
  gamePlay: <T = GamePlayPromise>() => T;
}

export interface ActionSubscription
  extends Promise<AsyncIterator<Action>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  type: () => Promise<AsyncIterator<ActionType>>;
  payload: <T = ActionPayloadSubscription>() => T;
  gamePlay: <T = GamePlaySubscription>() => T;
}

export interface ActionPayload {
  id: ID_Output;
}

export interface ActionPayloadPromise
  extends Promise<ActionPayload>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  instance: <T = EntityInstancePromise>() => T;
  state: <T = EntityStatePromise>() => T;
  item: <T = EntityInstancePromise>() => T;
  inputValues: <T = FragmentableArray<ActionPayloadInputValue>>(args?: {
    where?: ActionPayloadInputValueWhereInput;
    orderBy?: ActionPayloadInputValueOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  action: <T = ActionPromise>() => T;
}

export interface ActionPayloadSubscription
  extends Promise<AsyncIterator<ActionPayload>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  instance: <T = EntityInstanceSubscription>() => T;
  state: <T = EntityStateSubscription>() => T;
  item: <T = EntityInstanceSubscription>() => T;
  inputValues: <
    T = Promise<AsyncIterator<ActionPayloadInputValueSubscription>>
  >(args?: {
    where?: ActionPayloadInputValueWhereInput;
    orderBy?: ActionPayloadInputValueOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  action: <T = ActionSubscription>() => T;
}

export interface EntityInstance {
  id: ID_Output;
  name?: String;
  description?: String;
}

export interface EntityInstancePromise
  extends Promise<EntityInstance>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  game: <T = GamePromise>() => T;
  entity: <T = EntityPromise>() => T;
  fields: <T = FragmentableArray<EntityInstanceField>>(args?: {
    where?: EntityInstanceFieldWhereInput;
    orderBy?: EntityInstanceFieldOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  states: <T = FragmentableArray<EntityInstanceState>>(args?: {
    where?: EntityInstanceStateWhereInput;
    orderBy?: EntityInstanceStateOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface EntityInstanceSubscription
  extends Promise<AsyncIterator<EntityInstance>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  game: <T = GameSubscription>() => T;
  entity: <T = EntitySubscription>() => T;
  fields: <T = Promise<AsyncIterator<EntityInstanceFieldSubscription>>>(args?: {
    where?: EntityInstanceFieldWhereInput;
    orderBy?: EntityInstanceFieldOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  states: <T = Promise<AsyncIterator<EntityInstanceStateSubscription>>>(args?: {
    where?: EntityInstanceStateWhereInput;
    orderBy?: EntityInstanceStateOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface Game {
  id: ID_Output;
  name: String;
  slug: String;
  description?: String;
}

export interface GamePromise extends Promise<Game>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  slug: () => Promise<String>;
  description: () => Promise<String>;
  creator: <T = UserPromise>() => T;
  instances: <T = FragmentableArray<EntityInstance>>(args?: {
    where?: EntityInstanceWhereInput;
    orderBy?: EntityInstanceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  plays: <T = FragmentableArray<GamePlay>>(args?: {
    where?: GamePlayWhereInput;
    orderBy?: GamePlayOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface GameSubscription
  extends Promise<AsyncIterator<Game>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  slug: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  creator: <T = UserSubscription>() => T;
  instances: <T = Promise<AsyncIterator<EntityInstanceSubscription>>>(args?: {
    where?: EntityInstanceWhereInput;
    orderBy?: EntityInstanceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  plays: <T = Promise<AsyncIterator<GamePlaySubscription>>>(args?: {
    where?: GamePlayWhereInput;
    orderBy?: GamePlayOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface User {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
  slug: String;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  slug: () => Promise<String>;
  games: <T = FragmentableArray<Game>>(args?: {
    where?: GameWhereInput;
    orderBy?: GameOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  plays: <T = FragmentableArray<GamePlay>>(args?: {
    where?: GamePlayWhereInput;
    orderBy?: GamePlayOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  slug: () => Promise<AsyncIterator<String>>;
  games: <T = Promise<AsyncIterator<GameSubscription>>>(args?: {
    where?: GameWhereInput;
    orderBy?: GameOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  plays: <T = Promise<AsyncIterator<GamePlaySubscription>>>(args?: {
    where?: GamePlayWhereInput;
    orderBy?: GamePlayOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface GamePlay {
  id: ID_Output;
}

export interface GamePlayPromise extends Promise<GamePlay>, Fragmentable {
  id: () => Promise<ID_Output>;
  game: <T = GamePromise>() => T;
  player: <T = UserPromise>() => T;
  actions: <T = FragmentableArray<Action>>(args?: {
    where?: ActionWhereInput;
    orderBy?: ActionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface GamePlaySubscription
  extends Promise<AsyncIterator<GamePlay>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  game: <T = GameSubscription>() => T;
  player: <T = UserSubscription>() => T;
  actions: <T = Promise<AsyncIterator<ActionSubscription>>>(args?: {
    where?: ActionWhereInput;
    orderBy?: ActionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface Entity {
  id: ID_Output;
  name: String;
  description?: String;
  isTrigger: Boolean;
  isItem: Boolean;
  isObject: Boolean;
}

export interface EntityPromise extends Promise<Entity>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  isTrigger: () => Promise<Boolean>;
  isItem: () => Promise<Boolean>;
  isObject: () => Promise<Boolean>;
  fields: <T = FragmentableArray<EntityField>>(args?: {
    where?: EntityFieldWhereInput;
    orderBy?: EntityFieldOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  states: <T = FragmentableArray<EntityState>>(args?: {
    where?: EntityStateWhereInput;
    orderBy?: EntityStateOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  defaultState: <T = EntityStatePromise>() => T;
  instances: <T = FragmentableArray<EntityInstance>>(args?: {
    where?: EntityInstanceWhereInput;
    orderBy?: EntityInstanceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface EntitySubscription
  extends Promise<AsyncIterator<Entity>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  isTrigger: () => Promise<AsyncIterator<Boolean>>;
  isItem: () => Promise<AsyncIterator<Boolean>>;
  isObject: () => Promise<AsyncIterator<Boolean>>;
  fields: <T = Promise<AsyncIterator<EntityFieldSubscription>>>(args?: {
    where?: EntityFieldWhereInput;
    orderBy?: EntityFieldOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  states: <T = Promise<AsyncIterator<EntityStateSubscription>>>(args?: {
    where?: EntityStateWhereInput;
    orderBy?: EntityStateOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  defaultState: <T = EntityStateSubscription>() => T;
  instances: <T = Promise<AsyncIterator<EntityInstanceSubscription>>>(args?: {
    where?: EntityInstanceWhereInput;
    orderBy?: EntityInstanceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface EntityField {
  id: ID_Output;
  info?: String;
  label: String;
  type: FieldType;
  isMulti: Boolean;
  isSecret: Boolean;
}

export interface EntityFieldPromise extends Promise<EntityField>, Fragmentable {
  id: () => Promise<ID_Output>;
  info: () => Promise<String>;
  label: () => Promise<String>;
  type: () => Promise<FieldType>;
  isMulti: () => Promise<Boolean>;
  isSecret: () => Promise<Boolean>;
  entity: <T = EntityPromise>() => T;
}

export interface EntityFieldSubscription
  extends Promise<AsyncIterator<EntityField>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  info: () => Promise<AsyncIterator<String>>;
  label: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<FieldType>>;
  isMulti: () => Promise<AsyncIterator<Boolean>>;
  isSecret: () => Promise<AsyncIterator<Boolean>>;
  entity: <T = EntitySubscription>() => T;
}

export interface EntityState {
  id: ID_Output;
  name: String;
  description?: String;
}

export interface EntityStatePromise extends Promise<EntityState>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  outgoingTransitions: <T = FragmentableArray<EntityStateTransition>>(args?: {
    where?: EntityStateTransitionWhereInput;
    orderBy?: EntityStateTransitionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  incomingTransitions: <T = FragmentableArray<EntityStateTransition>>(args?: {
    where?: EntityStateTransitionWhereInput;
    orderBy?: EntityStateTransitionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  entity: <T = EntityPromise>() => T;
}

export interface EntityStateSubscription
  extends Promise<AsyncIterator<EntityState>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  outgoingTransitions: <
    T = Promise<AsyncIterator<EntityStateTransitionSubscription>>
  >(args?: {
    where?: EntityStateTransitionWhereInput;
    orderBy?: EntityStateTransitionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  incomingTransitions: <
    T = Promise<AsyncIterator<EntityStateTransitionSubscription>>
  >(args?: {
    where?: EntityStateTransitionWhereInput;
    orderBy?: EntityStateTransitionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  entity: <T = EntitySubscription>() => T;
}

export interface EntityStateTransition {
  id: ID_Output;
}

export interface EntityStateTransitionPromise
  extends Promise<EntityStateTransition>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  requiredActions: <T = FragmentableArray<ActionRequirement>>(args?: {
    where?: ActionRequirementWhereInput;
    orderBy?: ActionRequirementOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  from: <T = EntityStatePromise>() => T;
  to: <T = EntityStatePromise>() => T;
}

export interface EntityStateTransitionSubscription
  extends Promise<AsyncIterator<EntityStateTransition>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  requiredActions: <
    T = Promise<AsyncIterator<ActionRequirementSubscription>>
  >(args?: {
    where?: ActionRequirementWhereInput;
    orderBy?: ActionRequirementOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  from: <T = EntityStateSubscription>() => T;
  to: <T = EntityStateSubscription>() => T;
}

export interface ActionRequirement {
  id: ID_Output;
  type: ActionType;
  hints: String[];
}

export interface ActionRequirementPromise
  extends Promise<ActionRequirement>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  type: () => Promise<ActionType>;
  hints: () => Promise<String[]>;
  payload: <T = ActionRequirementPayloadPromise>() => T;
}

export interface ActionRequirementSubscription
  extends Promise<AsyncIterator<ActionRequirement>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  type: () => Promise<AsyncIterator<ActionType>>;
  hints: () => Promise<AsyncIterator<String[]>>;
  payload: <T = ActionRequirementPayloadSubscription>() => T;
}

export interface ActionRequirementPayload {
  id: ID_Output;
}

export interface ActionRequirementPayloadPromise
  extends Promise<ActionRequirementPayload>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  requiredEntity: <T = ActionRequirementPayloadEntityPromise>() => T;
  requiredValues: <
    T = FragmentableArray<ActionRequirementPayloadInputValue>
  >(args?: {
    where?: ActionRequirementPayloadInputValueWhereInput;
    orderBy?: ActionRequirementPayloadInputValueOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  actionRequirement: <T = ActionRequirementPromise>() => T;
}

export interface ActionRequirementPayloadSubscription
  extends Promise<AsyncIterator<ActionRequirementPayload>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  requiredEntity: <T = ActionRequirementPayloadEntitySubscription>() => T;
  requiredValues: <
    T = Promise<AsyncIterator<ActionRequirementPayloadInputValueSubscription>>
  >(args?: {
    where?: ActionRequirementPayloadInputValueWhereInput;
    orderBy?: ActionRequirementPayloadInputValueOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  actionRequirement: <T = ActionRequirementSubscription>() => T;
}

export interface ActionRequirementPayloadEntity {
  id: ID_Output;
}

export interface ActionRequirementPayloadEntityPromise
  extends Promise<ActionRequirementPayloadEntity>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  entity: <T = EntityPromise>() => T;
  state: <T = EntityStatePromise>() => T;
  payload: <T = ActionRequirementPayloadPromise>() => T;
}

export interface ActionRequirementPayloadEntitySubscription
  extends Promise<AsyncIterator<ActionRequirementPayloadEntity>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  entity: <T = EntitySubscription>() => T;
  state: <T = EntityStateSubscription>() => T;
  payload: <T = ActionRequirementPayloadSubscription>() => T;
}

export interface ActionRequirementPayloadInputValue {
  id: ID_Output;
  key: String;
  eqValue?: String;
  neqValue?: String;
}

export interface ActionRequirementPayloadInputValuePromise
  extends Promise<ActionRequirementPayloadInputValue>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  key: () => Promise<String>;
  eqField: <T = EntityFieldPromise>() => T;
  neqField: <T = EntityFieldPromise>() => T;
  eqValue: () => Promise<String>;
  neqValue: () => Promise<String>;
  payload: <T = ActionRequirementPayloadPromise>() => T;
}

export interface ActionRequirementPayloadInputValueSubscription
  extends Promise<AsyncIterator<ActionRequirementPayloadInputValue>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  key: () => Promise<AsyncIterator<String>>;
  eqField: <T = EntityFieldSubscription>() => T;
  neqField: <T = EntityFieldSubscription>() => T;
  eqValue: () => Promise<AsyncIterator<String>>;
  neqValue: () => Promise<AsyncIterator<String>>;
  payload: <T = ActionRequirementPayloadSubscription>() => T;
}

export interface EntityInstanceField {
  id: ID_Output;
  value?: String;
}

export interface EntityInstanceFieldPromise
  extends Promise<EntityInstanceField>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  field: <T = EntityFieldPromise>() => T;
  value: () => Promise<String>;
}

export interface EntityInstanceFieldSubscription
  extends Promise<AsyncIterator<EntityInstanceField>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  field: <T = EntityFieldSubscription>() => T;
  value: () => Promise<AsyncIterator<String>>;
}

export interface EntityInstanceState {
  id: ID_Output;
}

export interface EntityInstanceStatePromise
  extends Promise<EntityInstanceState>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  state: <T = EntityStatePromise>() => T;
  outgoingTransitions: <
    T = FragmentableArray<EntityInstanceStateTransition>
  >(args?: {
    where?: EntityInstanceStateTransitionWhereInput;
    orderBy?: EntityInstanceStateTransitionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  incomingTransitions: <
    T = FragmentableArray<EntityInstanceStateTransition>
  >(args?: {
    where?: EntityInstanceStateTransitionWhereInput;
    orderBy?: EntityInstanceStateTransitionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  unlockedBy: <T = EntityInstanceStateTransitionPromise>() => T;
  instance: <T = EntityInstancePromise>() => T;
}

export interface EntityInstanceStateSubscription
  extends Promise<AsyncIterator<EntityInstanceState>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  state: <T = EntityStateSubscription>() => T;
  outgoingTransitions: <
    T = Promise<AsyncIterator<EntityInstanceStateTransitionSubscription>>
  >(args?: {
    where?: EntityInstanceStateTransitionWhereInput;
    orderBy?: EntityInstanceStateTransitionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  incomingTransitions: <
    T = Promise<AsyncIterator<EntityInstanceStateTransitionSubscription>>
  >(args?: {
    where?: EntityInstanceStateTransitionWhereInput;
    orderBy?: EntityInstanceStateTransitionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  unlockedBy: <T = EntityInstanceStateTransitionSubscription>() => T;
  instance: <T = EntityInstanceSubscription>() => T;
}

export interface EntityInstanceStateTransition {
  id: ID_Output;
}

export interface EntityInstanceStateTransitionPromise
  extends Promise<EntityInstanceStateTransition>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  from: <T = EntityInstanceStatePromise>() => T;
  to: <T = EntityInstanceStatePromise>() => T;
  unlocks: <T = FragmentableArray<EntityInstanceState>>(args?: {
    where?: EntityInstanceStateWhereInput;
    orderBy?: EntityInstanceStateOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface EntityInstanceStateTransitionSubscription
  extends Promise<AsyncIterator<EntityInstanceStateTransition>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  from: <T = EntityInstanceStateSubscription>() => T;
  to: <T = EntityInstanceStateSubscription>() => T;
  unlocks: <
    T = Promise<AsyncIterator<EntityInstanceStateSubscription>>
  >(args?: {
    where?: EntityInstanceStateWhereInput;
    orderBy?: EntityInstanceStateOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ActionPayloadInputValue {
  id: ID_Output;
  key: String;
  value?: String;
}

export interface ActionPayloadInputValuePromise
  extends Promise<ActionPayloadInputValue>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  key: () => Promise<String>;
  value: () => Promise<String>;
}

export interface ActionPayloadInputValueSubscription
  extends Promise<AsyncIterator<ActionPayloadInputValue>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  key: () => Promise<AsyncIterator<String>>;
  value: () => Promise<AsyncIterator<String>>;
}

export interface ActionConnection {
  pageInfo: PageInfo;
  edges: ActionEdge[];
}

export interface ActionConnectionPromise
  extends Promise<ActionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ActionEdge>>() => T;
  aggregate: <T = AggregateActionPromise>() => T;
}

export interface ActionConnectionSubscription
  extends Promise<AsyncIterator<ActionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ActionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateActionSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface ActionEdge {
  node: Action;
  cursor: String;
}

export interface ActionEdgePromise extends Promise<ActionEdge>, Fragmentable {
  node: <T = ActionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ActionEdgeSubscription
  extends Promise<AsyncIterator<ActionEdge>>,
    Fragmentable {
  node: <T = ActionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateAction {
  count: Int;
}

export interface AggregateActionPromise
  extends Promise<AggregateAction>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateActionSubscription
  extends Promise<AsyncIterator<AggregateAction>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ActionPayloadConnection {
  pageInfo: PageInfo;
  edges: ActionPayloadEdge[];
}

export interface ActionPayloadConnectionPromise
  extends Promise<ActionPayloadConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ActionPayloadEdge>>() => T;
  aggregate: <T = AggregateActionPayloadPromise>() => T;
}

export interface ActionPayloadConnectionSubscription
  extends Promise<AsyncIterator<ActionPayloadConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ActionPayloadEdgeSubscription>>>() => T;
  aggregate: <T = AggregateActionPayloadSubscription>() => T;
}

export interface ActionPayloadEdge {
  node: ActionPayload;
  cursor: String;
}

export interface ActionPayloadEdgePromise
  extends Promise<ActionPayloadEdge>,
    Fragmentable {
  node: <T = ActionPayloadPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ActionPayloadEdgeSubscription
  extends Promise<AsyncIterator<ActionPayloadEdge>>,
    Fragmentable {
  node: <T = ActionPayloadSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateActionPayload {
  count: Int;
}

export interface AggregateActionPayloadPromise
  extends Promise<AggregateActionPayload>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateActionPayloadSubscription
  extends Promise<AsyncIterator<AggregateActionPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ActionPayloadInputValueConnection {
  pageInfo: PageInfo;
  edges: ActionPayloadInputValueEdge[];
}

export interface ActionPayloadInputValueConnectionPromise
  extends Promise<ActionPayloadInputValueConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ActionPayloadInputValueEdge>>() => T;
  aggregate: <T = AggregateActionPayloadInputValuePromise>() => T;
}

export interface ActionPayloadInputValueConnectionSubscription
  extends Promise<AsyncIterator<ActionPayloadInputValueConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<ActionPayloadInputValueEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateActionPayloadInputValueSubscription>() => T;
}

export interface ActionPayloadInputValueEdge {
  node: ActionPayloadInputValue;
  cursor: String;
}

export interface ActionPayloadInputValueEdgePromise
  extends Promise<ActionPayloadInputValueEdge>,
    Fragmentable {
  node: <T = ActionPayloadInputValuePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ActionPayloadInputValueEdgeSubscription
  extends Promise<AsyncIterator<ActionPayloadInputValueEdge>>,
    Fragmentable {
  node: <T = ActionPayloadInputValueSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateActionPayloadInputValue {
  count: Int;
}

export interface AggregateActionPayloadInputValuePromise
  extends Promise<AggregateActionPayloadInputValue>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateActionPayloadInputValueSubscription
  extends Promise<AsyncIterator<AggregateActionPayloadInputValue>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ActionRequirementConnection {
  pageInfo: PageInfo;
  edges: ActionRequirementEdge[];
}

export interface ActionRequirementConnectionPromise
  extends Promise<ActionRequirementConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ActionRequirementEdge>>() => T;
  aggregate: <T = AggregateActionRequirementPromise>() => T;
}

export interface ActionRequirementConnectionSubscription
  extends Promise<AsyncIterator<ActionRequirementConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ActionRequirementEdgeSubscription>>>() => T;
  aggregate: <T = AggregateActionRequirementSubscription>() => T;
}

export interface ActionRequirementEdge {
  node: ActionRequirement;
  cursor: String;
}

export interface ActionRequirementEdgePromise
  extends Promise<ActionRequirementEdge>,
    Fragmentable {
  node: <T = ActionRequirementPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ActionRequirementEdgeSubscription
  extends Promise<AsyncIterator<ActionRequirementEdge>>,
    Fragmentable {
  node: <T = ActionRequirementSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateActionRequirement {
  count: Int;
}

export interface AggregateActionRequirementPromise
  extends Promise<AggregateActionRequirement>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateActionRequirementSubscription
  extends Promise<AsyncIterator<AggregateActionRequirement>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ActionRequirementPayloadConnection {
  pageInfo: PageInfo;
  edges: ActionRequirementPayloadEdge[];
}

export interface ActionRequirementPayloadConnectionPromise
  extends Promise<ActionRequirementPayloadConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ActionRequirementPayloadEdge>>() => T;
  aggregate: <T = AggregateActionRequirementPayloadPromise>() => T;
}

export interface ActionRequirementPayloadConnectionSubscription
  extends Promise<AsyncIterator<ActionRequirementPayloadConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<ActionRequirementPayloadEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateActionRequirementPayloadSubscription>() => T;
}

export interface ActionRequirementPayloadEdge {
  node: ActionRequirementPayload;
  cursor: String;
}

export interface ActionRequirementPayloadEdgePromise
  extends Promise<ActionRequirementPayloadEdge>,
    Fragmentable {
  node: <T = ActionRequirementPayloadPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ActionRequirementPayloadEdgeSubscription
  extends Promise<AsyncIterator<ActionRequirementPayloadEdge>>,
    Fragmentable {
  node: <T = ActionRequirementPayloadSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateActionRequirementPayload {
  count: Int;
}

export interface AggregateActionRequirementPayloadPromise
  extends Promise<AggregateActionRequirementPayload>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateActionRequirementPayloadSubscription
  extends Promise<AsyncIterator<AggregateActionRequirementPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ActionRequirementPayloadEntityConnection {
  pageInfo: PageInfo;
  edges: ActionRequirementPayloadEntityEdge[];
}

export interface ActionRequirementPayloadEntityConnectionPromise
  extends Promise<ActionRequirementPayloadEntityConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ActionRequirementPayloadEntityEdge>>() => T;
  aggregate: <T = AggregateActionRequirementPayloadEntityPromise>() => T;
}

export interface ActionRequirementPayloadEntityConnectionSubscription
  extends Promise<AsyncIterator<ActionRequirementPayloadEntityConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<ActionRequirementPayloadEntityEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateActionRequirementPayloadEntitySubscription>() => T;
}

export interface ActionRequirementPayloadEntityEdge {
  node: ActionRequirementPayloadEntity;
  cursor: String;
}

export interface ActionRequirementPayloadEntityEdgePromise
  extends Promise<ActionRequirementPayloadEntityEdge>,
    Fragmentable {
  node: <T = ActionRequirementPayloadEntityPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ActionRequirementPayloadEntityEdgeSubscription
  extends Promise<AsyncIterator<ActionRequirementPayloadEntityEdge>>,
    Fragmentable {
  node: <T = ActionRequirementPayloadEntitySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateActionRequirementPayloadEntity {
  count: Int;
}

export interface AggregateActionRequirementPayloadEntityPromise
  extends Promise<AggregateActionRequirementPayloadEntity>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateActionRequirementPayloadEntitySubscription
  extends Promise<AsyncIterator<AggregateActionRequirementPayloadEntity>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ActionRequirementPayloadInputValueConnection {
  pageInfo: PageInfo;
  edges: ActionRequirementPayloadInputValueEdge[];
}

export interface ActionRequirementPayloadInputValueConnectionPromise
  extends Promise<ActionRequirementPayloadInputValueConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ActionRequirementPayloadInputValueEdge>>() => T;
  aggregate: <T = AggregateActionRequirementPayloadInputValuePromise>() => T;
}

export interface ActionRequirementPayloadInputValueConnectionSubscription
  extends Promise<AsyncIterator<ActionRequirementPayloadInputValueConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<
      AsyncIterator<ActionRequirementPayloadInputValueEdgeSubscription>
    >
  >() => T;
  aggregate: <
    T = AggregateActionRequirementPayloadInputValueSubscription
  >() => T;
}

export interface ActionRequirementPayloadInputValueEdge {
  node: ActionRequirementPayloadInputValue;
  cursor: String;
}

export interface ActionRequirementPayloadInputValueEdgePromise
  extends Promise<ActionRequirementPayloadInputValueEdge>,
    Fragmentable {
  node: <T = ActionRequirementPayloadInputValuePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ActionRequirementPayloadInputValueEdgeSubscription
  extends Promise<AsyncIterator<ActionRequirementPayloadInputValueEdge>>,
    Fragmentable {
  node: <T = ActionRequirementPayloadInputValueSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateActionRequirementPayloadInputValue {
  count: Int;
}

export interface AggregateActionRequirementPayloadInputValuePromise
  extends Promise<AggregateActionRequirementPayloadInputValue>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateActionRequirementPayloadInputValueSubscription
  extends Promise<AsyncIterator<AggregateActionRequirementPayloadInputValue>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface EntityConnection {
  pageInfo: PageInfo;
  edges: EntityEdge[];
}

export interface EntityConnectionPromise
  extends Promise<EntityConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<EntityEdge>>() => T;
  aggregate: <T = AggregateEntityPromise>() => T;
}

export interface EntityConnectionSubscription
  extends Promise<AsyncIterator<EntityConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<EntityEdgeSubscription>>>() => T;
  aggregate: <T = AggregateEntitySubscription>() => T;
}

export interface EntityEdge {
  node: Entity;
  cursor: String;
}

export interface EntityEdgePromise extends Promise<EntityEdge>, Fragmentable {
  node: <T = EntityPromise>() => T;
  cursor: () => Promise<String>;
}

export interface EntityEdgeSubscription
  extends Promise<AsyncIterator<EntityEdge>>,
    Fragmentable {
  node: <T = EntitySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateEntity {
  count: Int;
}

export interface AggregateEntityPromise
  extends Promise<AggregateEntity>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateEntitySubscription
  extends Promise<AsyncIterator<AggregateEntity>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface EntityFieldConnection {
  pageInfo: PageInfo;
  edges: EntityFieldEdge[];
}

export interface EntityFieldConnectionPromise
  extends Promise<EntityFieldConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<EntityFieldEdge>>() => T;
  aggregate: <T = AggregateEntityFieldPromise>() => T;
}

export interface EntityFieldConnectionSubscription
  extends Promise<AsyncIterator<EntityFieldConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<EntityFieldEdgeSubscription>>>() => T;
  aggregate: <T = AggregateEntityFieldSubscription>() => T;
}

export interface EntityFieldEdge {
  node: EntityField;
  cursor: String;
}

export interface EntityFieldEdgePromise
  extends Promise<EntityFieldEdge>,
    Fragmentable {
  node: <T = EntityFieldPromise>() => T;
  cursor: () => Promise<String>;
}

export interface EntityFieldEdgeSubscription
  extends Promise<AsyncIterator<EntityFieldEdge>>,
    Fragmentable {
  node: <T = EntityFieldSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateEntityField {
  count: Int;
}

export interface AggregateEntityFieldPromise
  extends Promise<AggregateEntityField>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateEntityFieldSubscription
  extends Promise<AsyncIterator<AggregateEntityField>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface EntityInstanceConnection {
  pageInfo: PageInfo;
  edges: EntityInstanceEdge[];
}

export interface EntityInstanceConnectionPromise
  extends Promise<EntityInstanceConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<EntityInstanceEdge>>() => T;
  aggregate: <T = AggregateEntityInstancePromise>() => T;
}

export interface EntityInstanceConnectionSubscription
  extends Promise<AsyncIterator<EntityInstanceConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<EntityInstanceEdgeSubscription>>>() => T;
  aggregate: <T = AggregateEntityInstanceSubscription>() => T;
}

export interface EntityInstanceEdge {
  node: EntityInstance;
  cursor: String;
}

export interface EntityInstanceEdgePromise
  extends Promise<EntityInstanceEdge>,
    Fragmentable {
  node: <T = EntityInstancePromise>() => T;
  cursor: () => Promise<String>;
}

export interface EntityInstanceEdgeSubscription
  extends Promise<AsyncIterator<EntityInstanceEdge>>,
    Fragmentable {
  node: <T = EntityInstanceSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateEntityInstance {
  count: Int;
}

export interface AggregateEntityInstancePromise
  extends Promise<AggregateEntityInstance>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateEntityInstanceSubscription
  extends Promise<AsyncIterator<AggregateEntityInstance>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface EntityInstanceFieldConnection {
  pageInfo: PageInfo;
  edges: EntityInstanceFieldEdge[];
}

export interface EntityInstanceFieldConnectionPromise
  extends Promise<EntityInstanceFieldConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<EntityInstanceFieldEdge>>() => T;
  aggregate: <T = AggregateEntityInstanceFieldPromise>() => T;
}

export interface EntityInstanceFieldConnectionSubscription
  extends Promise<AsyncIterator<EntityInstanceFieldConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<EntityInstanceFieldEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateEntityInstanceFieldSubscription>() => T;
}

export interface EntityInstanceFieldEdge {
  node: EntityInstanceField;
  cursor: String;
}

export interface EntityInstanceFieldEdgePromise
  extends Promise<EntityInstanceFieldEdge>,
    Fragmentable {
  node: <T = EntityInstanceFieldPromise>() => T;
  cursor: () => Promise<String>;
}

export interface EntityInstanceFieldEdgeSubscription
  extends Promise<AsyncIterator<EntityInstanceFieldEdge>>,
    Fragmentable {
  node: <T = EntityInstanceFieldSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateEntityInstanceField {
  count: Int;
}

export interface AggregateEntityInstanceFieldPromise
  extends Promise<AggregateEntityInstanceField>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateEntityInstanceFieldSubscription
  extends Promise<AsyncIterator<AggregateEntityInstanceField>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface EntityInstanceStateConnection {
  pageInfo: PageInfo;
  edges: EntityInstanceStateEdge[];
}

export interface EntityInstanceStateConnectionPromise
  extends Promise<EntityInstanceStateConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<EntityInstanceStateEdge>>() => T;
  aggregate: <T = AggregateEntityInstanceStatePromise>() => T;
}

export interface EntityInstanceStateConnectionSubscription
  extends Promise<AsyncIterator<EntityInstanceStateConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<EntityInstanceStateEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateEntityInstanceStateSubscription>() => T;
}

export interface EntityInstanceStateEdge {
  node: EntityInstanceState;
  cursor: String;
}

export interface EntityInstanceStateEdgePromise
  extends Promise<EntityInstanceStateEdge>,
    Fragmentable {
  node: <T = EntityInstanceStatePromise>() => T;
  cursor: () => Promise<String>;
}

export interface EntityInstanceStateEdgeSubscription
  extends Promise<AsyncIterator<EntityInstanceStateEdge>>,
    Fragmentable {
  node: <T = EntityInstanceStateSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateEntityInstanceState {
  count: Int;
}

export interface AggregateEntityInstanceStatePromise
  extends Promise<AggregateEntityInstanceState>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateEntityInstanceStateSubscription
  extends Promise<AsyncIterator<AggregateEntityInstanceState>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface EntityInstanceStateTransitionConnection {
  pageInfo: PageInfo;
  edges: EntityInstanceStateTransitionEdge[];
}

export interface EntityInstanceStateTransitionConnectionPromise
  extends Promise<EntityInstanceStateTransitionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<EntityInstanceStateTransitionEdge>>() => T;
  aggregate: <T = AggregateEntityInstanceStateTransitionPromise>() => T;
}

export interface EntityInstanceStateTransitionConnectionSubscription
  extends Promise<AsyncIterator<EntityInstanceStateTransitionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<EntityInstanceStateTransitionEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateEntityInstanceStateTransitionSubscription>() => T;
}

export interface EntityInstanceStateTransitionEdge {
  node: EntityInstanceStateTransition;
  cursor: String;
}

export interface EntityInstanceStateTransitionEdgePromise
  extends Promise<EntityInstanceStateTransitionEdge>,
    Fragmentable {
  node: <T = EntityInstanceStateTransitionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface EntityInstanceStateTransitionEdgeSubscription
  extends Promise<AsyncIterator<EntityInstanceStateTransitionEdge>>,
    Fragmentable {
  node: <T = EntityInstanceStateTransitionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateEntityInstanceStateTransition {
  count: Int;
}

export interface AggregateEntityInstanceStateTransitionPromise
  extends Promise<AggregateEntityInstanceStateTransition>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateEntityInstanceStateTransitionSubscription
  extends Promise<AsyncIterator<AggregateEntityInstanceStateTransition>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface EntityStateConnection {
  pageInfo: PageInfo;
  edges: EntityStateEdge[];
}

export interface EntityStateConnectionPromise
  extends Promise<EntityStateConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<EntityStateEdge>>() => T;
  aggregate: <T = AggregateEntityStatePromise>() => T;
}

export interface EntityStateConnectionSubscription
  extends Promise<AsyncIterator<EntityStateConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<EntityStateEdgeSubscription>>>() => T;
  aggregate: <T = AggregateEntityStateSubscription>() => T;
}

export interface EntityStateEdge {
  node: EntityState;
  cursor: String;
}

export interface EntityStateEdgePromise
  extends Promise<EntityStateEdge>,
    Fragmentable {
  node: <T = EntityStatePromise>() => T;
  cursor: () => Promise<String>;
}

export interface EntityStateEdgeSubscription
  extends Promise<AsyncIterator<EntityStateEdge>>,
    Fragmentable {
  node: <T = EntityStateSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateEntityState {
  count: Int;
}

export interface AggregateEntityStatePromise
  extends Promise<AggregateEntityState>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateEntityStateSubscription
  extends Promise<AsyncIterator<AggregateEntityState>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface EntityStateTransitionConnection {
  pageInfo: PageInfo;
  edges: EntityStateTransitionEdge[];
}

export interface EntityStateTransitionConnectionPromise
  extends Promise<EntityStateTransitionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<EntityStateTransitionEdge>>() => T;
  aggregate: <T = AggregateEntityStateTransitionPromise>() => T;
}

export interface EntityStateTransitionConnectionSubscription
  extends Promise<AsyncIterator<EntityStateTransitionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<EntityStateTransitionEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateEntityStateTransitionSubscription>() => T;
}

export interface EntityStateTransitionEdge {
  node: EntityStateTransition;
  cursor: String;
}

export interface EntityStateTransitionEdgePromise
  extends Promise<EntityStateTransitionEdge>,
    Fragmentable {
  node: <T = EntityStateTransitionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface EntityStateTransitionEdgeSubscription
  extends Promise<AsyncIterator<EntityStateTransitionEdge>>,
    Fragmentable {
  node: <T = EntityStateTransitionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateEntityStateTransition {
  count: Int;
}

export interface AggregateEntityStateTransitionPromise
  extends Promise<AggregateEntityStateTransition>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateEntityStateTransitionSubscription
  extends Promise<AsyncIterator<AggregateEntityStateTransition>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface GameConnection {
  pageInfo: PageInfo;
  edges: GameEdge[];
}

export interface GameConnectionPromise
  extends Promise<GameConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<GameEdge>>() => T;
  aggregate: <T = AggregateGamePromise>() => T;
}

export interface GameConnectionSubscription
  extends Promise<AsyncIterator<GameConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<GameEdgeSubscription>>>() => T;
  aggregate: <T = AggregateGameSubscription>() => T;
}

export interface GameEdge {
  node: Game;
  cursor: String;
}

export interface GameEdgePromise extends Promise<GameEdge>, Fragmentable {
  node: <T = GamePromise>() => T;
  cursor: () => Promise<String>;
}

export interface GameEdgeSubscription
  extends Promise<AsyncIterator<GameEdge>>,
    Fragmentable {
  node: <T = GameSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateGame {
  count: Int;
}

export interface AggregateGamePromise
  extends Promise<AggregateGame>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateGameSubscription
  extends Promise<AsyncIterator<AggregateGame>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface GamePlayConnection {
  pageInfo: PageInfo;
  edges: GamePlayEdge[];
}

export interface GamePlayConnectionPromise
  extends Promise<GamePlayConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<GamePlayEdge>>() => T;
  aggregate: <T = AggregateGamePlayPromise>() => T;
}

export interface GamePlayConnectionSubscription
  extends Promise<AsyncIterator<GamePlayConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<GamePlayEdgeSubscription>>>() => T;
  aggregate: <T = AggregateGamePlaySubscription>() => T;
}

export interface GamePlayEdge {
  node: GamePlay;
  cursor: String;
}

export interface GamePlayEdgePromise
  extends Promise<GamePlayEdge>,
    Fragmentable {
  node: <T = GamePlayPromise>() => T;
  cursor: () => Promise<String>;
}

export interface GamePlayEdgeSubscription
  extends Promise<AsyncIterator<GamePlayEdge>>,
    Fragmentable {
  node: <T = GamePlaySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateGamePlay {
  count: Int;
}

export interface AggregateGamePlayPromise
  extends Promise<AggregateGamePlay>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateGamePlaySubscription
  extends Promise<AsyncIterator<AggregateGamePlay>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface ActionSubscriptionPayload {
  mutation: MutationType;
  node: Action;
  updatedFields: String[];
  previousValues: ActionPreviousValues;
}

export interface ActionSubscriptionPayloadPromise
  extends Promise<ActionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ActionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ActionPreviousValuesPromise>() => T;
}

export interface ActionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ActionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ActionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ActionPreviousValuesSubscription>() => T;
}

export interface ActionPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  type: ActionType;
}

export interface ActionPreviousValuesPromise
  extends Promise<ActionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  type: () => Promise<ActionType>;
}

export interface ActionPreviousValuesSubscription
  extends Promise<AsyncIterator<ActionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  type: () => Promise<AsyncIterator<ActionType>>;
}

export interface ActionPayloadSubscriptionPayload {
  mutation: MutationType;
  node: ActionPayload;
  updatedFields: String[];
  previousValues: ActionPayloadPreviousValues;
}

export interface ActionPayloadSubscriptionPayloadPromise
  extends Promise<ActionPayloadSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ActionPayloadPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ActionPayloadPreviousValuesPromise>() => T;
}

export interface ActionPayloadSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ActionPayloadSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ActionPayloadSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ActionPayloadPreviousValuesSubscription>() => T;
}

export interface ActionPayloadPreviousValues {
  id: ID_Output;
}

export interface ActionPayloadPreviousValuesPromise
  extends Promise<ActionPayloadPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface ActionPayloadPreviousValuesSubscription
  extends Promise<AsyncIterator<ActionPayloadPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface ActionPayloadInputValueSubscriptionPayload {
  mutation: MutationType;
  node: ActionPayloadInputValue;
  updatedFields: String[];
  previousValues: ActionPayloadInputValuePreviousValues;
}

export interface ActionPayloadInputValueSubscriptionPayloadPromise
  extends Promise<ActionPayloadInputValueSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ActionPayloadInputValuePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ActionPayloadInputValuePreviousValuesPromise>() => T;
}

export interface ActionPayloadInputValueSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ActionPayloadInputValueSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ActionPayloadInputValueSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <
    T = ActionPayloadInputValuePreviousValuesSubscription
  >() => T;
}

export interface ActionPayloadInputValuePreviousValues {
  id: ID_Output;
  key: String;
  value?: String;
}

export interface ActionPayloadInputValuePreviousValuesPromise
  extends Promise<ActionPayloadInputValuePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  key: () => Promise<String>;
  value: () => Promise<String>;
}

export interface ActionPayloadInputValuePreviousValuesSubscription
  extends Promise<AsyncIterator<ActionPayloadInputValuePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  key: () => Promise<AsyncIterator<String>>;
  value: () => Promise<AsyncIterator<String>>;
}

export interface ActionRequirementSubscriptionPayload {
  mutation: MutationType;
  node: ActionRequirement;
  updatedFields: String[];
  previousValues: ActionRequirementPreviousValues;
}

export interface ActionRequirementSubscriptionPayloadPromise
  extends Promise<ActionRequirementSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ActionRequirementPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ActionRequirementPreviousValuesPromise>() => T;
}

export interface ActionRequirementSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ActionRequirementSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ActionRequirementSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ActionRequirementPreviousValuesSubscription>() => T;
}

export interface ActionRequirementPreviousValues {
  id: ID_Output;
  type: ActionType;
  hints: String[];
}

export interface ActionRequirementPreviousValuesPromise
  extends Promise<ActionRequirementPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  type: () => Promise<ActionType>;
  hints: () => Promise<String[]>;
}

export interface ActionRequirementPreviousValuesSubscription
  extends Promise<AsyncIterator<ActionRequirementPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  type: () => Promise<AsyncIterator<ActionType>>;
  hints: () => Promise<AsyncIterator<String[]>>;
}

export interface ActionRequirementPayloadSubscriptionPayload {
  mutation: MutationType;
  node: ActionRequirementPayload;
  updatedFields: String[];
  previousValues: ActionRequirementPayloadPreviousValues;
}

export interface ActionRequirementPayloadSubscriptionPayloadPromise
  extends Promise<ActionRequirementPayloadSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ActionRequirementPayloadPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ActionRequirementPayloadPreviousValuesPromise>() => T;
}

export interface ActionRequirementPayloadSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ActionRequirementPayloadSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ActionRequirementPayloadSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <
    T = ActionRequirementPayloadPreviousValuesSubscription
  >() => T;
}

export interface ActionRequirementPayloadPreviousValues {
  id: ID_Output;
}

export interface ActionRequirementPayloadPreviousValuesPromise
  extends Promise<ActionRequirementPayloadPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface ActionRequirementPayloadPreviousValuesSubscription
  extends Promise<AsyncIterator<ActionRequirementPayloadPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface ActionRequirementPayloadEntitySubscriptionPayload {
  mutation: MutationType;
  node: ActionRequirementPayloadEntity;
  updatedFields: String[];
  previousValues: ActionRequirementPayloadEntityPreviousValues;
}

export interface ActionRequirementPayloadEntitySubscriptionPayloadPromise
  extends Promise<ActionRequirementPayloadEntitySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ActionRequirementPayloadEntityPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <
    T = ActionRequirementPayloadEntityPreviousValuesPromise
  >() => T;
}

export interface ActionRequirementPayloadEntitySubscriptionPayloadSubscription
  extends Promise<
      AsyncIterator<ActionRequirementPayloadEntitySubscriptionPayload>
    >,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ActionRequirementPayloadEntitySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <
    T = ActionRequirementPayloadEntityPreviousValuesSubscription
  >() => T;
}

export interface ActionRequirementPayloadEntityPreviousValues {
  id: ID_Output;
}

export interface ActionRequirementPayloadEntityPreviousValuesPromise
  extends Promise<ActionRequirementPayloadEntityPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface ActionRequirementPayloadEntityPreviousValuesSubscription
  extends Promise<AsyncIterator<ActionRequirementPayloadEntityPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface ActionRequirementPayloadInputValueSubscriptionPayload {
  mutation: MutationType;
  node: ActionRequirementPayloadInputValue;
  updatedFields: String[];
  previousValues: ActionRequirementPayloadInputValuePreviousValues;
}

export interface ActionRequirementPayloadInputValueSubscriptionPayloadPromise
  extends Promise<ActionRequirementPayloadInputValueSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ActionRequirementPayloadInputValuePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <
    T = ActionRequirementPayloadInputValuePreviousValuesPromise
  >() => T;
}

export interface ActionRequirementPayloadInputValueSubscriptionPayloadSubscription
  extends Promise<
      AsyncIterator<ActionRequirementPayloadInputValueSubscriptionPayload>
    >,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ActionRequirementPayloadInputValueSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <
    T = ActionRequirementPayloadInputValuePreviousValuesSubscription
  >() => T;
}

export interface ActionRequirementPayloadInputValuePreviousValues {
  id: ID_Output;
  key: String;
  eqValue?: String;
  neqValue?: String;
}

export interface ActionRequirementPayloadInputValuePreviousValuesPromise
  extends Promise<ActionRequirementPayloadInputValuePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  key: () => Promise<String>;
  eqValue: () => Promise<String>;
  neqValue: () => Promise<String>;
}

export interface ActionRequirementPayloadInputValuePreviousValuesSubscription
  extends Promise<
      AsyncIterator<ActionRequirementPayloadInputValuePreviousValues>
    >,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  key: () => Promise<AsyncIterator<String>>;
  eqValue: () => Promise<AsyncIterator<String>>;
  neqValue: () => Promise<AsyncIterator<String>>;
}

export interface EntitySubscriptionPayload {
  mutation: MutationType;
  node: Entity;
  updatedFields: String[];
  previousValues: EntityPreviousValues;
}

export interface EntitySubscriptionPayloadPromise
  extends Promise<EntitySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = EntityPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = EntityPreviousValuesPromise>() => T;
}

export interface EntitySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<EntitySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = EntitySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = EntityPreviousValuesSubscription>() => T;
}

export interface EntityPreviousValues {
  id: ID_Output;
  name: String;
  description?: String;
  isTrigger: Boolean;
  isItem: Boolean;
  isObject: Boolean;
}

export interface EntityPreviousValuesPromise
  extends Promise<EntityPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  isTrigger: () => Promise<Boolean>;
  isItem: () => Promise<Boolean>;
  isObject: () => Promise<Boolean>;
}

export interface EntityPreviousValuesSubscription
  extends Promise<AsyncIterator<EntityPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  isTrigger: () => Promise<AsyncIterator<Boolean>>;
  isItem: () => Promise<AsyncIterator<Boolean>>;
  isObject: () => Promise<AsyncIterator<Boolean>>;
}

export interface EntityFieldSubscriptionPayload {
  mutation: MutationType;
  node: EntityField;
  updatedFields: String[];
  previousValues: EntityFieldPreviousValues;
}

export interface EntityFieldSubscriptionPayloadPromise
  extends Promise<EntityFieldSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = EntityFieldPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = EntityFieldPreviousValuesPromise>() => T;
}

export interface EntityFieldSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<EntityFieldSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = EntityFieldSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = EntityFieldPreviousValuesSubscription>() => T;
}

export interface EntityFieldPreviousValues {
  id: ID_Output;
  info?: String;
  label: String;
  type: FieldType;
  isMulti: Boolean;
  isSecret: Boolean;
}

export interface EntityFieldPreviousValuesPromise
  extends Promise<EntityFieldPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  info: () => Promise<String>;
  label: () => Promise<String>;
  type: () => Promise<FieldType>;
  isMulti: () => Promise<Boolean>;
  isSecret: () => Promise<Boolean>;
}

export interface EntityFieldPreviousValuesSubscription
  extends Promise<AsyncIterator<EntityFieldPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  info: () => Promise<AsyncIterator<String>>;
  label: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<FieldType>>;
  isMulti: () => Promise<AsyncIterator<Boolean>>;
  isSecret: () => Promise<AsyncIterator<Boolean>>;
}

export interface EntityInstanceSubscriptionPayload {
  mutation: MutationType;
  node: EntityInstance;
  updatedFields: String[];
  previousValues: EntityInstancePreviousValues;
}

export interface EntityInstanceSubscriptionPayloadPromise
  extends Promise<EntityInstanceSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = EntityInstancePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = EntityInstancePreviousValuesPromise>() => T;
}

export interface EntityInstanceSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<EntityInstanceSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = EntityInstanceSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = EntityInstancePreviousValuesSubscription>() => T;
}

export interface EntityInstancePreviousValues {
  id: ID_Output;
  name?: String;
  description?: String;
}

export interface EntityInstancePreviousValuesPromise
  extends Promise<EntityInstancePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
}

export interface EntityInstancePreviousValuesSubscription
  extends Promise<AsyncIterator<EntityInstancePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
}

export interface EntityInstanceFieldSubscriptionPayload {
  mutation: MutationType;
  node: EntityInstanceField;
  updatedFields: String[];
  previousValues: EntityInstanceFieldPreviousValues;
}

export interface EntityInstanceFieldSubscriptionPayloadPromise
  extends Promise<EntityInstanceFieldSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = EntityInstanceFieldPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = EntityInstanceFieldPreviousValuesPromise>() => T;
}

export interface EntityInstanceFieldSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<EntityInstanceFieldSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = EntityInstanceFieldSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = EntityInstanceFieldPreviousValuesSubscription>() => T;
}

export interface EntityInstanceFieldPreviousValues {
  id: ID_Output;
  value?: String;
}

export interface EntityInstanceFieldPreviousValuesPromise
  extends Promise<EntityInstanceFieldPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  value: () => Promise<String>;
}

export interface EntityInstanceFieldPreviousValuesSubscription
  extends Promise<AsyncIterator<EntityInstanceFieldPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  value: () => Promise<AsyncIterator<String>>;
}

export interface EntityInstanceStateSubscriptionPayload {
  mutation: MutationType;
  node: EntityInstanceState;
  updatedFields: String[];
  previousValues: EntityInstanceStatePreviousValues;
}

export interface EntityInstanceStateSubscriptionPayloadPromise
  extends Promise<EntityInstanceStateSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = EntityInstanceStatePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = EntityInstanceStatePreviousValuesPromise>() => T;
}

export interface EntityInstanceStateSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<EntityInstanceStateSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = EntityInstanceStateSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = EntityInstanceStatePreviousValuesSubscription>() => T;
}

export interface EntityInstanceStatePreviousValues {
  id: ID_Output;
}

export interface EntityInstanceStatePreviousValuesPromise
  extends Promise<EntityInstanceStatePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface EntityInstanceStatePreviousValuesSubscription
  extends Promise<AsyncIterator<EntityInstanceStatePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface EntityInstanceStateTransitionSubscriptionPayload {
  mutation: MutationType;
  node: EntityInstanceStateTransition;
  updatedFields: String[];
  previousValues: EntityInstanceStateTransitionPreviousValues;
}

export interface EntityInstanceStateTransitionSubscriptionPayloadPromise
  extends Promise<EntityInstanceStateTransitionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = EntityInstanceStateTransitionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <
    T = EntityInstanceStateTransitionPreviousValuesPromise
  >() => T;
}

export interface EntityInstanceStateTransitionSubscriptionPayloadSubscription
  extends Promise<
      AsyncIterator<EntityInstanceStateTransitionSubscriptionPayload>
    >,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = EntityInstanceStateTransitionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <
    T = EntityInstanceStateTransitionPreviousValuesSubscription
  >() => T;
}

export interface EntityInstanceStateTransitionPreviousValues {
  id: ID_Output;
}

export interface EntityInstanceStateTransitionPreviousValuesPromise
  extends Promise<EntityInstanceStateTransitionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface EntityInstanceStateTransitionPreviousValuesSubscription
  extends Promise<AsyncIterator<EntityInstanceStateTransitionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface EntityStateSubscriptionPayload {
  mutation: MutationType;
  node: EntityState;
  updatedFields: String[];
  previousValues: EntityStatePreviousValues;
}

export interface EntityStateSubscriptionPayloadPromise
  extends Promise<EntityStateSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = EntityStatePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = EntityStatePreviousValuesPromise>() => T;
}

export interface EntityStateSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<EntityStateSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = EntityStateSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = EntityStatePreviousValuesSubscription>() => T;
}

export interface EntityStatePreviousValues {
  id: ID_Output;
  name: String;
  description?: String;
}

export interface EntityStatePreviousValuesPromise
  extends Promise<EntityStatePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
}

export interface EntityStatePreviousValuesSubscription
  extends Promise<AsyncIterator<EntityStatePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
}

export interface EntityStateTransitionSubscriptionPayload {
  mutation: MutationType;
  node: EntityStateTransition;
  updatedFields: String[];
  previousValues: EntityStateTransitionPreviousValues;
}

export interface EntityStateTransitionSubscriptionPayloadPromise
  extends Promise<EntityStateTransitionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = EntityStateTransitionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = EntityStateTransitionPreviousValuesPromise>() => T;
}

export interface EntityStateTransitionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<EntityStateTransitionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = EntityStateTransitionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = EntityStateTransitionPreviousValuesSubscription>() => T;
}

export interface EntityStateTransitionPreviousValues {
  id: ID_Output;
}

export interface EntityStateTransitionPreviousValuesPromise
  extends Promise<EntityStateTransitionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface EntityStateTransitionPreviousValuesSubscription
  extends Promise<AsyncIterator<EntityStateTransitionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface GameSubscriptionPayload {
  mutation: MutationType;
  node: Game;
  updatedFields: String[];
  previousValues: GamePreviousValues;
}

export interface GameSubscriptionPayloadPromise
  extends Promise<GameSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = GamePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = GamePreviousValuesPromise>() => T;
}

export interface GameSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<GameSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = GameSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = GamePreviousValuesSubscription>() => T;
}

export interface GamePreviousValues {
  id: ID_Output;
  name: String;
  slug: String;
  description?: String;
}

export interface GamePreviousValuesPromise
  extends Promise<GamePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  slug: () => Promise<String>;
  description: () => Promise<String>;
}

export interface GamePreviousValuesSubscription
  extends Promise<AsyncIterator<GamePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  slug: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
}

export interface GamePlaySubscriptionPayload {
  mutation: MutationType;
  node: GamePlay;
  updatedFields: String[];
  previousValues: GamePlayPreviousValues;
}

export interface GamePlaySubscriptionPayloadPromise
  extends Promise<GamePlaySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = GamePlayPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = GamePlayPreviousValuesPromise>() => T;
}

export interface GamePlaySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<GamePlaySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = GamePlaySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = GamePlayPreviousValuesSubscription>() => T;
}

export interface GamePlayPreviousValues {
  id: ID_Output;
}

export interface GamePlayPreviousValuesPromise
  extends Promise<GamePlayPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface GamePlayPreviousValuesSubscription
  extends Promise<AsyncIterator<GamePlayPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface UserPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
  slug: String;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  slug: () => Promise<String>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  slug: () => Promise<AsyncIterator<String>>;
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Action",
    embedded: false
  },
  {
    name: "ActionPayload",
    embedded: false
  },
  {
    name: "ActionPayloadInputValue",
    embedded: false
  },
  {
    name: "ActionRequirement",
    embedded: false
  },
  {
    name: "ActionRequirementPayload",
    embedded: false
  },
  {
    name: "ActionRequirementPayloadEntity",
    embedded: false
  },
  {
    name: "ActionRequirementPayloadInputValue",
    embedded: false
  },
  {
    name: "ActionType",
    embedded: false
  },
  {
    name: "Entity",
    embedded: false
  },
  {
    name: "EntityField",
    embedded: false
  },
  {
    name: "EntityInstance",
    embedded: false
  },
  {
    name: "EntityInstanceField",
    embedded: false
  },
  {
    name: "EntityInstanceState",
    embedded: false
  },
  {
    name: "EntityInstanceStateTransition",
    embedded: false
  },
  {
    name: "EntityState",
    embedded: false
  },
  {
    name: "EntityStateTransition",
    embedded: false
  },
  {
    name: "FieldType",
    embedded: false
  },
  {
    name: "Game",
    embedded: false
  },
  {
    name: "GamePlay",
    embedded: false
  },
  {
    name: "User",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
